<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://slowlog.github.io</id>
    <title>slowlog</title>
    <updated>2019-06-01T08:27:51.405Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://slowlog.github.io"/>
    <link rel="self" href="https://slowlog.github.io/atom.xml"/>
    <subtitle>slow life slow log.</subtitle>
    <logo>https://slowlog.github.io/images/avatar.png</logo>
    <icon>https://slowlog.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, slowlog</rights>
    <entry>
        <title type="html"><![CDATA[Docker 学习笔记]]></title>
        <id>https://slowlog.github.io/post/docker-xue-xi-bi-ji</id>
        <link href="https://slowlog.github.io/post/docker-xue-xi-bi-ji">
        </link>
        <updated>2019-06-01T08:27:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="初识-docker">初识 docker</h3>
<p>docker 是一项可以将应用及其依赖打包成一个容器进行分发、从而保证环境一致性的技术，采用 Go 开发，于 2013 年初由 Docker.Inc 发布。Docker 的出现使软件开发及部署流程变得更为简洁与规范。</p>
<p><img src="https://user-images.githubusercontent.com/16852041/28628085-32160114-7256-11e7-9c6a-fcaa267cf638.jpg" alt="r351508499tj"></p>
<h3 id="docker-特点">docker 特点</h3>
<p><strong>轻型</strong> Docker 容器间共享服务器的系统库、系统工具、运行环境及代码，这样便能够保证运行一致性。</p>
<p><strong>开源</strong> Docker 容器基于一系列开源标准，运行于所有的主流 Linux 操作系统。</p>
<p><strong>安全</strong> 容器间的应用相互隔离，底层基础设施为其提供了一层额外保护。</p>
<h3 id="部署流程">部署流程</h3>
<p><img src="https://user-images.githubusercontent.com/16852041/28628145-62dad7c0-7256-11e7-8c4a-bb328bb836cc.png" alt="b5bbc6c76f197902"></p>
<h3 id="docker-的安装">docker 的安装</h3>
<pre><code>1. 安装必要的一些系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2

2. 添加软件源信息
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

3. 安装 docker-ce
sudo yum makecache fast
sudo yum -y install docker-ce

4. 启动 docker 服务
sudo service docker start

5. docker 加速器
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
  &quot;registry-mirrors&quot;: [&quot;https://6ty2vtn5.mirror.aliyuncs.com&quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<h3 id="docker-常用命令">docker 常用命令</h3>
<pre><code>#从 registry 拉取 image
docker pull  

#推送 image 到 registry
docker push  

#开启/停止/重启 container
docker start/stop/restart  

#默认显示正在运行中的 container
docker ps  

#显示最后一次创建的 container, 包括未运行的  
docker ps -l 

#显示所有的 container, 包括未运行的
docker ps -a 

#删除一个或多个 container
docker rm containerId  

#删除一个或多个 image
docker rmi imageId     

#进入container bash
docker exec -it containerId bash 

#列出所有的 images
docker images -a  

#创建网关
docker network create &lt;name&gt;

#列出所有网关
docker network ls

#创建 container 并将 container 的端口映射到宿主机的端口
docker run -i -t -p hostport:containerport image

#寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的 image
docker build

# 查看 docker 的版本号，包括客户端、服务端、依赖的 Go 等
docker version 

# 将容器做成镜像
docker commit -m  &quot;提示信息&quot;   -a  &quot;作者&quot;   容器ID  镜像名称

# 移除已退出的容器并删除 id 为&lt;None&gt;的 image
docker ps -a | grep &quot;Exited&quot; | awk '{print $1 }'|xargs docker rm
docker rmi $(docker images -a | grep &quot;^&lt;none&gt;&quot; | awk &quot;{print $3}&quot;)

</code></pre>
<blockquote>
<p>注: 容器内可以使用 <code>ping 容器名</code>  来查看是否在同一局域网内, 当挂载目录出现权限问题时, 应检查宿主机与容器的用户与组的id是否一致</p>
</blockquote>
<h3 id="dockerfile-设置时区">dockerfile 设置时区</h3>
<pre><code># 方式一
ENV TZ=Asia/Shanghai
RUN ln -sf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone

# 方式二
RUN apk --update add tzdata \
&amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[个人书签&收藏]]></title>
        <id>https://slowlog.github.io/post/ge-ren-shu-qian-andshou-cang</id>
        <link href="https://slowlog.github.io/post/ge-ren-shu-qian-andshou-cang">
        </link>
        <updated>2019-06-01T08:26:22.000Z</updated>
        <content type="html"><![CDATA[<h4 id="0-centos7-上安装-redis">0. <a href="http://www.linuxidc.com/Linux/2017-09/147198.htm">CentOS7 上安装 Redis</a></h4>
<h4 id="1-centos7-上部署-rsync-服务">1. <a href="https://www.linuxidc.com/Linux/2017-10/147900.htm">CentOS7 上部署 Rsync 服务</a></h4>
<h4 id="2-linux-目录结构详细介绍">2. <a href="http://yangrong.blog.51cto.com/6945369/1288072">Linux 目录结构详细介绍</a></h4>
<h4 id="3-gitlab-搭建与维护基于-docker">3. <a href="http://www.linuxidc.com/Linux/2016-05/131886.htm">GitLab 搭建与维护(基于 docker)</a></h4>
<h4 id="4-gulp-详细入门教程">4. <a href="http://www.ydcss.com/archives/18/comment-page-5">Gulp 详细入门教程</a></h4>
<h4 id="5-跨域资源共享-cors-详解">5. <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></h4>
<h4 id="6-webpack入门">6. <a href="https://segmentfault.com/a/1190000006178770">Webpack入门</a></h4>
<h4 id="7-react-学习资源汇总">7. <a href="http://www.imooc.com/article/14902">React 学习资源汇总</a></h4>
<h4 id="8-docker-入门">8. <a href="https://segmentfault.com/a/1190000009544565">Docker 入门</a></h4>
<h4 id="9-react-入门">9. <a href="https://segmentfault.com/a/1190000012921279">React 入门</a></h4>
<h4 id="10-30-分钟快速入门-docker-教程">10. <a href="https://mp.weixin.qq.com/s/DY3pLat1ehudP624Io73Hg">30 分钟快速入门 Docker 教程</a></h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《计算机是怎样跑起来的》读书笔记]]></title>
        <id>https://slowlog.github.io/post/lesslessji-suan-ji-shi-zen-yang-pao-qi-lai-de-greatergreater-du-shu-bi-ji</id>
        <link href="https://slowlog.github.io/post/lesslessji-suan-ji-shi-zen-yang-pao-qi-lai-de-greatergreater-du-shu-bi-ji">
        </link>
        <updated>2019-06-01T08:24:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="计算机的三大原则">计算机的三大原则</h2>
<h3 id="计算机的输入-运算-输出">计算机的输入、运算、输出</h3>
<p>从硬件上来讲，可以说计算机是执行输入、运算、输出三种操作的机器。计算机的硬件由大量的IC（集成电路）组成，每块IC上都有大量的引脚，这些引脚有些用于输入，有些用于输出。IC会在其内部对外部输入的信息进行运算，并把运算结果输出到外部。运算这个词听起来也许有些难以理解，但实际上就是计算的意思。举例来说，1+2=3，计算机所做的事就是“输入”数据1和2，然后对它们进行加法“运算”，最后“输出”计算结果3。</p>
<p>其实计算机就是一台简单的机器，它也只能做这三件事。输入、运算、输出必须成套出现，缺一不可。为什呢？</p>
<ul>
<li>第一，现在的计算机还没有发展到能通过自发的思考创造出信息的地步，因此不输入信息计算计就不能工作。</li>
<li>第二，计算机不能不执行任何运算，如果只是使输入的信息绕过运算环节直接输出，那么这就是电线而不是计算机了，如果不进行运算，计算机也就没有什么存在的意义了。</li>
<li>第三，如果不输出结果，那么这也不是计算机而只是堆积信息的垃圾箱了，所以输出也必不可少。</li>
</ul>
<h3 id="程序是指令和数据的集合">程序是指令和数据的集合</h3>
<p>什么是程序？所谓程序，其实非常简单，只不过是指令和数据的集合。无论程序多么高深多么复杂，其内容也都是指令和数据。
那什么是指令？所谓指令，就是控制计算进行输入、运算、输出的命令。</p>
<p>程序中的数据分为两类，一类是作为指令执行对象的输入数据， 一类是从指令的执行结果得到的输出数据。一般在编写程序的过程中，都要先编译再执行，所谓编译就是把用编译型语言如C、Java、C#等编写的源文件转换成字节码文件，也可以说是机器语言或原生代码。因为计算机只认识二进制，只认识0和1，由一大堆的二进制代码组成的程序就叫机器码、机器语言。</p>
<pre><code>        1 bit  = 1 二进制数据
        1 byte = 8 bit
        1 字母 = 1 byte = 8 bit
        1 汉字 = 2 byte = 16 bit
</code></pre>
<h3 id="计算机的处理方式">计算机的处理方式</h3>
<p>计算机有计算机的处理方法，这是三大原则中的最后一点。计算机本身只不过是为我们处理特定工作的机器。如果计算机能自己干活的话，那么我们的生活太美好了，我一定买很多台。不过遗憾的是目前还没有这样的计算机，现在的计算机终究是受人支配的工具。</p>
<p>对计算机来说什么都是数字。用数字表示所有信息，这就是一个很具代表性的计算机式的处理方式，这一点正是和人类的思维习惯不一样的地方。例如，人们会用”蓝色“”红色“之类的词语描述有关的颜色信息。可是换做计算机的话，就不得不用数字表示颜色信息。</p>
<p>例如：用”0,0,255“表示蓝色，用”255,0,0“表示红色，用”255,0,255“表示由蓝色和红色混合而成的紫色。不光是颜色，计算机对文字的处理也是如此。计算机内部会先把文字转换成相应的数字再做处理，这样的数字叫做”字符编码“。总之，计算机会什么都用数字来表示。</p>
<h3 id="程序的流程分为三种">程序的流程分为三种</h3>
<p><img src="https://user-images.githubusercontent.com/16852041/38287659-66b0a2f8-37fe-11e8-9f11-28f62e538040.png" alt="default">
<img src="https://user-images.githubusercontent.com/16852041/38287664-6dbb0d54-37fe-11e8-9425-73e2dddc6d04.png" alt="default">
<img src="https://user-images.githubusercontent.com/16852041/38303396-89f2e2f0-3838-11e8-9d7e-012183a6736f.png" alt="wx20180404-184523"></p>
<ul>
<li>顺序执行是按照指令记录在内存中的先后顺序依次执行的一种流程。</li>
<li>而循环则是在程序的特定范围内反复执行若干次的一种流程。</li>
<li>条件分支是根据若干个条件的成立与否，在程序的流程中产生若干个分支的一种流程。</li>
</ul>
<p>无论规模多么大多么复杂的程序，都是通过把以上三种流程组合起来实现的。</p>
<h3 id="面向对象编程抽象">面向对象编程&amp;抽象</h3>
<p>面向对象编程是一种基于以下思路的程序设计方法:将关注点置于对象(Object)本身，对象的构成要素包含对象的行为及操作 B，以此为基础进行编程。这种方法使程序易于复用，软件的生产效率因而得以提升。其中所使用的主要编程技巧有继承、封装、多态三种。</p>
<ul>
<li>观点1：面向对象编程通过把组件拼装到一起构建程序</li>
<li>观点2：面向对象编程能够提升程序的开发效率和可维护性</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16852041/38287879-d102061e-37ff-11e8-8b74-049d11e37756.png" alt="wx20180404-120028"></p>
<ul>
<li>观点3：面向对象编程就是在为现实世界建模</li>
</ul>
<p>程序可以在计算机上实现现实世界中的业务和娱乐活动。计算机 本身并没有特定的用途，而是程序赋予了计算机各种各样的用途。在面向对象编程中，可以通过“这个是由什么样的对象构成的呢?”这样的观点来分析即将转换成程序的现实世界。这种分析过程叫作“建模”。 可以说建模对于开发者而言，反映的是他们的世界观，也就是在他们的眼中现实世界看起来是什么样子的。
<img src="https://user-images.githubusercontent.com/16852041/38287893-e43ebe84-37ff-11e8-9409-5bc5bed1026d.png" alt="wx20180404-114525"></p>
<ul>
<li>观点4：面向对象编程可以借助 UML 设计程序
<img src="https://user-images.githubusercontent.com/16852041/38287897-ea38aca0-37ff-11e8-8ad1-df612f347cce.png" alt="wx20180404-115909"></li>
</ul>
<p>面向对象软件开发的一个基本方法就是抽象，到底什么是抽象呢?
抽象是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征。
例如苹果、香蕉、生梨、葡萄、桃子等，它们共同的特性就是水果。
得出水果概念的过程，就是一个抽象的过程。
要抽象，就必须进行比较，没有比较就无法找到共同的部分。
共同特征是指那些能把一类事物与他类事物区分开来的特征，
这些具有区分作用的特征又称本质特征。</p>
<p>因此抽取事物的共同特征就是抽取事物的本质特征，舍弃不同特征。
所以抽象的过程也是一个裁剪的过程，不同的、非本质性的特征全部裁剪掉了。
所谓的共同特征，是相对的，是指从某一个刻面看是共同的。
比如，对于汽车和大米，从买卖的角度看都是商品，都有价格，
这是他们的共同的特征，而从其他方面来比较是，他们则是不同的。</p>
<p>所以在抽象时，同与不同，决定于从什么角度上来抽象。
抽象的角度取决于分析问题的目的。 在软件开发过程中，
识别稳定的需求、识别核心的需求、识别概念性的需求、
设计系统的架构、定义系统中构件之间的接口关系等等都是抽象的过程，
都是反应系统的本质特征的过程。
抽象的，才是稳定的，才是永恒的。 抽象的反义词是具体。</p>
<p>开发人员往往会说：“你讲的太抽象了，能不能讲的具体一点?”在开发语言中，
有抽象类，有具体类，具体类可以继承自抽象类，可以实例化。
抽象类可以派生出众多的不同的具体类。所谓：“一生二，二生三，三生万物”。
系统的稳定体现在抽象类，系统的变化体现在具体类。抽象类的层次要高于具体类。
系统因抽象而稳定，因抽象而生动。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx 学习笔记]]></title>
        <id>https://slowlog.github.io/post/nginx-xue-xi-bi-ji</id>
        <link href="https://slowlog.github.io/post/nginx-xue-xi-bi-ji">
        </link>
        <updated>2019-06-01T08:16:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="nginx-特性">Nginx 特性</h3>
<ul>
<li>IO 多路复用epoll</li>
<li>轻量级，功能模块少，代码模块化</li>
<li>CPU（affinity）</li>
<li>sendfile</li>
</ul>
<h3 id="nginx-安装">Nginx 安装</h3>
<pre><code># 设置nginx的yum源
vim /etc/yum.repos.d/nginx.repo

[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1

# 列出nginx源
yum list | grep nginx

# 安装
yum install -y nginx

# 查看版本
nginx -v

# 查看安装的编译参数
nginx -V
2&gt;&amp;1 nginx -V | tr ' ' '\n'|grep ssl

# 查看安装目录
rpm -ql nginx

</code></pre>
<h3 id="nginx-目录">Nginx 目录</h3>
<pre><code># nginx日志轮转，用于logrotate服务的日志切割
/etc/logrotate.d/nginx

# 主配置文件
/etc/nginx/nginx.conf

# cgi，fastcgi 配置文件
/etc/nginx/fastcgi_params
/etc/nginx/uwsgi_params
/etc/nginx/scgi_params

# http协议的Content-Type与扩展名对应关系
/etc/nginx/mime.types

# nginx模块目录
/usr/lib64/nginx/modules
/etc/nginx/modules

# nginx缓存目录
/var/cache/nginx

# nginx日志目录
/var/log/nginx

</code></pre>
<h3 id="nginx-编译参数">Nginx 编译参数</h3>
<pre><code># 设置安装目录与路径
--prefix=/etc/nginx
--sbin-path=/usr/sbin/nginx
--modules-path=/usr/lib64/nginx/modules
--conf-path=/etc/nginx/nginx.conf
--error-log-path=/var/log/nginx/error.log
--http-log-path=/var/log/nginx/access.log
--pid-path=/var/run/nginx.pid
--lock-path=/var/run/nginx.lock

# 设置nginx进程启动的用户与用户组
--user=nginx
--group=nginx

# 开启支持https请求，需已安装openssl
--with-http_ssl_module
# 开启gzip支持
--with-http_gzip_static_module
# 开启ipv6支持
--with-ipv6

</code></pre>
<h3 id="nginx-配置文件详解">Nginx 配置文件详解</h3>
<pre><code>user  nginx; #设置nginx服务运行时用户
worker_processes  1; #工作进程数,通常设置成和cpu的核数相等

error_log  /var/log/nginx/error.log warn; #错误日志
pid        /var/run/nginx.pid; #nginx服务启动时pid


events {
    worker_connections  1024; #每个进程允许处理的最大连接数
    use   epoll; #设置nginx使用什么内核模型，epoll仅用于linux2.6以上内核,可以大大提高nginx的性能
}


http {
    #设置mime类型,类型由mime.type文件定义
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    #设置日志格式（nginx内置变量，可自定义变量）
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    #访问日志
    access_log  /var/log/nginx/access.log  main;

    #启用高效传输文件的模式  
    sendfile        on;
    #tcp_nopush     on; #必须和sendfile搭配使用

    #连接超时时间
    keepalive_timeout  65;

    #gzip压缩相关（相对来说对文本的压缩效率是最高的）
    gzip  on;
    gzip_http_version 1.1;
    gzip_comp_level 2;
    gzip_types text/css image/jpeg image/png image/gif;

    #设置请求缓冲
    client_header_buffer_size    128k;
    large_client_header_buffers  4 128k;

    server {
    #监听端口
    listen       80;
    #定义使用 www.baidu.com访问
    server_name  www.baidu.com;

    #访问日志
    access_log  /var/log/nginx/host.access.log  main;

    #监听nginx当前的连接信息
    location /my_stub {
      stub_status;
    }

    #默认请求
    location / {
        #网站默认根目录位置
        root html;

        #定义首页索引文件的名称
        index index.php index.html index.htm;
    }

    #定义错误提示页面
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    #静态文件nginx自己处理
    location ~ ^/(images|javascript|js|css|flash|media|static)/ {
        #设置静态文件的过期时间
        expires 7d;

        #防盗链配置
        valid_referers none blocked 192.168.1.102
        if ($invalid_referer){
          return 403;
        }
        root /www/images;
    }

    #PHP脚本请求全部转发到FastCGI处理
    location ~ \.php$ {
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        include        fastcgi_params;
    }

}
    #引入其他server
    #include /etc/nginx/conf.d/*.conf;
}

</code></pre>
<h3 id="访问控制">访问控制</h3>
<pre><code>http{

  # 跨域相关配置
  add_header 'Access-Control-Allow-Origin' '*';
  add_header 'Access-Control-Allow-Headers' 'X-Requested-With';
  add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS';

  #连接限制
  limit_conn_zone $binary_remote_addr zone=conn_zone:1m;
  #请求限制
  limit_req_zone $binary_remote_addr zone=req_zone:1m rate=1r/s;

  server{

    location / {

      #内容替换,默认匹配第一个，设置为off则匹配所有
      #sub_filter '&lt;a&gt;baidu&lt;/a&gt;' '&lt;p&gt;BAIDU&lt;/p&gt;';
      #sub_filter_once off;

      #启用随机主页
      #random_index on;    

      #启用连接限制(参考http模块配置的空间)
      limit_conn conn_zone 1;
      #启用请求限制(参考http模块配置的空间)
      limit_req zone=req_zone burst=3 nodelay;

      #限制指定ip不允许访问（反之则允许指定ip访问）
      deny 192.168.1.102;
      allow all;

      #用户认证配置
      auth_basic &quot;please input your pwd!&quot;;
      auth_basic_user_file /path/htpasswd/auth_file;
    }

    #禁止访问 .htxx 文件
    location ~ /\.ht {
        deny  all;
    }
  }
}

</code></pre>
<h3 id="负载均衡">负载均衡</h3>
<pre><code>http{

  upstream your_server_name {
    server 127.0.0.1:8001 weight=5;
    server 127.0.0.1:8002 backup;
    server 127.0.0.1:8003 max_fails=1 fail_timeout=10;

    #可通过iptables策略测试以下配置
    #backup 备份服务器
    #max_fails 允许请求失败的次数
    #fail_timeout 经过max_fails失败后，服务暂停的时间
    #max_conns 最大连接数
    #weight 加权轮询weight值越大，分配到的访问几率越高
    #ip_hash 每个请求按访问IP的hash结果分配，一个IP固定到一个后端服务器，
    #url_hash 每个请求按访问url的hash结果分配
    #least_conn 哪个机器连接数少，就分配到哪个，类似加权轮询
  }

  server{

    location / {
        proxy_pass http://your_server_name;
        include proxy_params;
    }
  }
}
</code></pre>
<h3 id="rewrite规则">Rewrite规则</h3>
<pre><code>break 使用break会停止匹配下面的location，直接发起请求www.xxx.com/test/,然而root目录下没有test这个目录，所以404
last  停止当前这个请求，并根据rewrite匹配的规则重新发起一个请求，重写后的规则，会继续用重写后的值去匹配下一个的location
redirect 返回302临时重定向
permanent 返回301永久重定向（浏览器会保留永久重定向的结果，不会再向服务端发起请求）
server{
    root /www;
    # url重写
    location / {
       rewrite ^/course-(\d+)-(\d+)-(\d+)\.html$ /course/$1/$2/course_$3.html break;

      #如果是谷歌浏览器打开的则重定向到指定位置  
       if ($http_user_agent ~* Chrome) {
           rewrite ^/nignx http://www.baidu.com/nginx/index.html redirect;
       }
       #如果访问的路径不存在，则转发到指定位置
       if (!-f $request_filename) {
          rewrite ^/(.*)$ http://www.baidu.com/$1 redirect;
       }

      index index.html index.htm;
    }
    location ~ ^/break {
       rewrite ^/break /test/ break;
    }
    location ~ ^/last {
       rewrite ^/last /test/ last;
    }
    location /test/ {
       default_type application/json;
       return 200 '{&quot;status&quot;:&quot;success&quot;}';
    }
}
</code></pre>
<h3 id="nginx安全下载模块">nginx安全下载模块</h3>
<pre><code>location / {
    secure_link $arg_md5,$arg_expires;
    secure_link_md5 &quot;$secure_link_expires$uri xxxx(自定义key)&quot;;

   if ($secure_link = &quot;&quot;) {
     return 403;
   }
   if ($secure_link = &quot;0&quot;){
      return 410;
   }
}

需生成如下请求下载示例：
http://www.xxxx.com/download/xxx.jpg?md5=xxxx&amp;expires=1587845

</code></pre>
<h3 id="nginx-geoip模块">nginx geoip模块</h3>
<pre><code>基于GeoIP MaxMind
#主要使用场景
1.区别国内外作http访问规则
2.区别国内城市地域作http访问规则

#安装
yum install -y nginx-module-geoip

#GeoIP库
mkdir /etc/nginx/geoip &amp;&amp; cd /etc/nginx/geoip
wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz
wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz
参考：http://www.52os.net/articles/configure-nginx-using-geoip-allow-whitelist.html

#解压
gunzip GeoLiteCity.dat.gz GeoIP.dat.gz

vim /etc/nginx/nginx.conf

#加载模块
load_module &quot;modules/ngx_http_geoip_module.so&quot;;
load_module &quot;modules/ngx_stream_geoip_module.so&quot;;

http{

  #读取GeoIP库文件
  geoip_country /etc/nginx/geoip/GeoIP.dat;
  geoip_city /etc/nginx/geoip/GeoLiteCity.dat;


  server{

    location / {
      # 拒绝国外ip访问
      if ($geoip_country_code != CN) {
            return 403;
      }
    }
    #测试获取自己的出口ip
    location /myip {
       default_type application/json;
       return 200 '{&quot;ip&quot;:&quot;$remote_addr&quot;,&quot;country&quot;:&quot;$geoip_country_name&quot;,&quot;country_code&quot;:&quot;$geoip_country_code&quot;,&quot;city&quot;:&quot;$geoip_city&quot;}';
   }

  }

}

</code></pre>
<h3 id="获取用户真实ip地址">获取用户真实ip地址</h3>
<ul>
<li>当存在多级代理的情况下，可通过第一级代理设置头信息传递给后端服务</li>
</ul>
<h3 id="nginx-常见错误码">Nginx 常见错误码</h3>
<ul>
<li>403 forbidden #权限问题</li>
<li>404 not found #文件没找到</li>
<li>413 request entity too large #用户上传的文件超过限制</li>
<li>502 bad gateway #后端服务无响应</li>
<li>504 gateway time-out #后端服务执行超时</li>
</ul>
<h3 id="ab压力测试工具">ab压力测试工具</h3>
<pre><code>yum install -y httpd-tools

ab -n 2000 -c 2 http://127.0.0.1/
-n 总的请求数
-c 并发数
-k 是否开启长连接
</code></pre>
<h3 id="系统与-nginx-性能优化">系统与 nginx 性能优化</h3>
<h4 id="文件句柄">文件句柄</h4>
<pre><code>linux 一切皆文件，当每一次用户发起一个请求就会产生一个文件句柄，文件句柄就是一个索引。

#设置方式
- 系统全局性修改
- 用户局部性修改
- 进程局部性修改

vim /etc/security/limits.conf

#root用户
root soft nofile 65535
root hard nofile 65535
#所有用户
*    soft nofile 25535
*    hard nofile 25535
#针对进程
vim /etc/nginx/conf/nginx.conf
worker_rlimit_nofile 15535;(小站点建议1w以上，大站点3w以上)

</code></pre>
<h4 id="cpu亲和性配置">cpu亲和性配置</h4>
<pre><code>#查看当前物理cpu个数
cat /proc/cpuinfo | grep &quot;physical id&quot;|sort|uniq|wc -l

#查看当前单个cpu的核心
cat /proc/cpuinfo | grep &quot;cpu cores&quot;|uniq

#nginx配置
worker_processes 2;（建议配成cpu虚拟核心的个数）
worker_cpu_affinity auto;

# 查看当前nginx进程cpu使用情况
ps -eo pid,args,psr|grep [n]ginx

</code></pre>
<h4 id="通用配置">通用配置</h4>
<pre><code>error_log /var/log/nginx/error.log warn;

events{
  use epoll;
  worker_connections 10240;
}

http{
    charset utf-8;
    access_log /var/log/nginx/access.log main;
}


</code></pre>
<h3 id="nginx安全策略">nginx安全策略</h3>
<h4 id="文件上传漏洞">文件上传漏洞</h4>
<pre><code>location ^~ /upload {
  root /opt/app/images;
  if ($request_filename ~* (.*)\.php) {
      return 403;
  }
}
</code></pre>
<h4 id="基于lua-nginx-moduleopenresty的web应用防火墙">基于lua-nginx-module(openresty)的web应用防火墙</h4>
<p><code>https://github.com/loveshell/ngx_lua_waf</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 学习笔记]]></title>
        <id>https://slowlog.github.io/post/java-xue-xi-bi-ji</id>
        <link href="https://slowlog.github.io/post/java-xue-xi-bi-ji">
        </link>
        <updated>2019-06-01T08:02:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="java-简述">Java 简述</h3>
<ul>
<li>JRE = JVM + JavaSE标准类库</li>
<li>JDK = JRE + 开发工具集（例如javac编译工具）</li>
<li>Java SE = Java标准版</li>
<li>Java EE = Java企业版</li>
<li>Java ME = 为移动设备提供了基于Java环境的开发与应用平台</li>
<li>Java 执行流程 = 源文件(Program.java)-&gt;编译器-&gt;字节码文件(Program.class)-&gt;解释器-&gt;Program</li>
</ul>
<h3 id="java-数据类型">Java 数据类型</h3>
<pre><code>一、基本数据类型：
byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0

short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0

int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0

long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L

float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0

double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0

char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空

boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false

二、引用数据类型：

类、接口类型、数组类型、枚举类型、注解类型。

区别： 
基本数据类型是值传递，引用数据类型是引用传递

基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。

引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。

例如，有一个类Person,有属性name,age,带有参的构造方法，

Person p = new Person(&quot;zhangsan&quot;,20);

在内存中的具体创建过程是：

1.首先在栈内存中位其p分配一块空间;

2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值&quot;&quot;，0；

3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作；

4.调用构造方法，为两个属性赋值为&quot;Tom&quot;,20；（注意这个时候p与Person对象之间还没有建立联系）；

5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。

相关知识：

静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配。

堆区：  一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错

栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限

</code></pre>
<h3 id="java-面向对象">Java 面向对象</h3>
<h3 id="类和对象">类和对象</h3>
<pre><code>1. 类是抽象的概念, 仅仅是模板, 比如说 : &quot;人&quot;
2. 类确定对象将会拥有的特征(属性)和行为(方法)
3. 对象是一个能看得到, 摸得着的具体实物，是类的实例表现
4. 万物皆对象, 客观存在的事物皆为对象
5. 属性是对象具有的各种静态特征
</code></pre>
<h3 id="类的定义-对象实例化的过程">类的定义、对象实例化的过程</h3>
<pre><code>1. 类的重要性 : 所有Java程序都以类class为组织单元
2. 什么是类?
    类是模子, 确定对象将会拥有的特征(属性)和行为(方法)
3. 类的组成 : 属性和方法
4. 定义一个类的步骤 : 
    a. 定义类名
    b. 编写类的属性
    c. 编写类的方法
</code></pre>
<pre><code>对象实例化的过程
1. 声明对象 Person p，在内存的栈区开辟空间
2. 实例对象 new Person()，在内存的堆区开辟空间
3. 赋值 Person p = new Person()，将堆空间的地址赋值给栈空间
</code></pre>
<h3 id="成员变量和局部变量">成员变量和局部变量</h3>
<pre><code>1. 成员变量
      在类中定义, 用来描述对象将要有什么
      成员变量可以被本类的所有方法使用, 也可以被与本类有关系的其他方法使用
2. 局部变量
      在类的方法中定义, 在方法中临时保存数据
      只能在本方法中使用
区别 : 
      1. 作用域不同
        局部变量的作用域仅限于定义它的方法
        成员变量的作用域在整个类的内部都是可见的
      2. 初始值不同
        Java会给成员变量一个初始值
        Java不会给局部变量赋予初始值
      3. 在同一个方法中不允许有同名局部变量
        在不同的方法中, 可以有同名局部变量
      4. 两类变量同名时, 局部变量具有更高的优先级
</code></pre>
<h3 id="构造方法-静态变量与方法">构造方法、静态变量与方法</h3>
<pre><code>构造方法
1. 使用new + 构造方法 创建一个新的对象
2. 构造方法是定义在Java类中的一个用来初始化对象的方法
3. 构造方法名与类同名且没有返回值
4. 无参构造方法：当没有指定构造方法时, 系统会自动添加无参的构造方法
5. 构造方法的重载：方法名相同, 但参数不同的多个方法, 调用时会自动根据不同的参数选择相应的方法
</code></pre>
<pre><code>静态变量与方法

Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。
静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问~~
static 可以修饰变量、方法和代码块
PS : 静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！~~

1.静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。
    如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。
2.在普通成员方法中，则可以直接访问同类的非静态变量和静态变量
3.静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。
</code></pre>
<h3 id="初始化块代码块">初始化块（代码块）</h3>
<pre><code>
代码块：在Java中，使用{}括起来的代码成为代码块
根据其位置和声明的不同，可以分为
	局部代码块：局部位置，用于限定变量的生命周期
	构造代码块：在类中的成员位置，用{}括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。
		作用：可以把多个构造方法的共同代码放在一起。
	静态代码块：在类中的成员位置，用{}括起来的代码，只不过它用static修饰
		作用：一般是对类进行初始化
	面试题？
		静态代码块、构造代码块、构造方法的执行顺序？
		静态-》构造代码块-》构造方法
		静态代码块：只执行一次
		构造方法：每次调用构造方法都执行
 
</code></pre>
<h3 id="封装-继承-多态">封装、继承、多态</h3>
<pre><code>封装
1.概念 : 
  将类的某些信息隐藏在类内部, 不允许外部程序直接访问, 而是通过该类提供的方法来实现对隐藏信息的操作和访问
2.好处 : 
  a.只能通过规定的方法访问数据
  b.隐藏类的实例细节, 方便修改和实现
3.封装的实现步骤 : 
  第一步, 修改属性的可见性---设为private
  第二步, 创建getter/setter方法---用于属性读写
  第三步, 在getter/setter方法中加入属性控制语句---对属性值的合法性进行判断

</code></pre>
<pre><code>继承
1. Java中的继承是单一继承(一个子类只能有一个父类)
2. 继承是类与类的一种关系, 是一种&quot;A is a B&quot;的关系，例如说：学生是人，狗和猫都是动物 
3. 继承的好处：子类拥有父类所有的属性和方法，属性和方法的修饰符不能是&quot;private&quot;，实现代码复用，缩短开发周期
4. 继承的初始化构建顺序：父类静态成员-&gt;子类静态成员-&gt;父类对象构建-&gt;子类对象构建

</code></pre>
<pre><code>多态
1. 对象的多种形态，继承是多态的实现基础
2. 父类的引用可以指向本类或子类的实例(子类的引用不可以指向父类，必须通过强制转换)
3. 创建本类对象时, 调用的方法为本类的方法或为子类重写的方法或者继承的方法
</code></pre>
<h3 id="引用类型转换">引用类型转换</h3>
<pre><code>1. 向上类型转换(隐式/自动类型转换), 是小类型到大类型的转换
2. 向下类型转换(强制类型转换), 是大类型到小类型
   ps : 向上类型转换(无风险), 向下类型转换(有风险)
3. instanceof运算符, 来解决引用对象的类型, 避免类型转换的安全性问题

</code></pre>
<h3 id="java中的包package">Java中的包(package)</h3>
<pre><code>1. 包的作用:
    管理Java文件
    解决同名文件冲突
2. 定义包 : package 包名
    注 : 必须放在Java源程序的第一行
          包名可以用&quot;.&quot;号隔开
3. 系统中的包
    java.(功能).(类)
    java.lang.(类)  包含java语言基础的类
    java.util.(类)  包含java语言中各种工具类
    java.io.(类)  包含输入,输出相关功能
4. 包的使用
    (1),可以通过import关键字, 在某个文件使用其他文件中的类.
    (2),Java中, 包的命名规范全是小写字母拼写
    (3),使用的时候不但可以加载某个包下的所有文件, 也可以加载某个具体子包下的所有文件

</code></pre>
<h3 id="java中的访问修饰符">Java中的访问修饰符</h3>
<pre><code>访问修饰符 --- 可以修饰属性和方法的访问范围
访问修饰符  本类  同包  子类  其他
private     √
默认         √     √
protected   √      √    √
public      √      √    √    √

</code></pre>
<h3 id="java中的-this-super-final-关键字">Java中的 this、super、final 关键字</h3>
<pre><code>ps：在构造方法中，this和super是不能同时出现的

this
1. this关键字代表当前类对象的引用
2. 通过this关键字可以访问当前类的构造方法，成员属性，成员方法，不能在静态方法中使用

   
super
1. super关键字代表父类对象的引用
2. 通过super关键字可以访问父类的构造方法，成员属性，成员方法，不能在静态方法中使用

final
1. final关键字，使用final关键字做标识有&quot;最终的&quot;含义
2. final可以修饰类, 方法, 属性和变量
   final修饰类, 则该类不允许被继承
   final修饰方法, 则该方法不允许被覆盖(重写)
   final修饰属性，则该类的属性不会进行隐式的初始化(类的初始化属性必须有值)，或者在构造方法中赋值(但只能选其一)
   final修饰变量, 则该变量的值只能赋一次值, 即为常量

</code></pre>
<h3 id="方法重写与方法重载">方法重写与方法重载</h3>
<pre><code>重写：
在满足继承关系的子类中，方法名，参数个数，顺序，返回值与父类相同，访问修饰符的限定范围大于等于父类方法

重载：
在同一个类中，方法名相同，参数个数，顺序，类型不同，返回值类型，访问修饰符任意

</code></pre>
<h3 id="object类-抽象类">Object类、抽象类</h3>
<pre><code>Object类是所有类的父类，每个类都可以使用Object类中定义的方法
例如：equals()，toString()

</code></pre>
<pre><code>抽象类
1. 语法定义 : 
   抽象类前使用abstract关键字修饰, 则该类为抽象类
2. 应用场景 : 
   a.在某些情况下, 某个父类只是知道其子类应该包含怎样的方法, 但无法准确知道这些子类如何实现这些方法
     也就是说抽象类是约束子类必须有哪些方法, 而并不关注子类是如何实现的
   b.从多个具有相同特征的类中抽象出一个抽象类, 以这个抽象类作为子类的模板, 从而避免了子类设计的随意性
3. 作用 : 
   限制规定子类必须实现某些方法, 但不关注实现细节
4. 使用规则 : 
   a. abstract定义抽象类
   b. abstract定义抽象方法, 只有声明, 不需要实现
   c. 包含抽象方法的类是抽象类
   d. 抽象类中可以包含普通方法, 也可以没有抽象方法
   e. 抽象类不能直接创建, 可以定义引用变量

</code></pre>
<h3 id="接口">接口</h3>
<pre><code>1. 接口概念 :  (是一种规范, 是用来约束类的)
   接口可以理解为一种特殊的类, 由全局常量和公共的抽象方法所组成
   类是一种具体的实现体, 而接口定义了某一批类所需要遵守的规范, 接口不关心这些类的内部数据, 
   也不关心这些类里方法的实现细节, 它只规定这些类里必须提供某些方法
2. 接口定义 
   和类定义不同, 定义接口不再使用class关键字, 而是使用interface关键字
接口定义的基本语法 : 
   [修饰符] (abstract 此关键字肯定有, 如果没有,系统会默认加上) interface 接口名 [extends 父接口1, 父接口2...]
   {
     零到多个常量定义...
     零到多个抽象方法的定义...  
   }
   接口就是用来被继承, 被实现的, 修饰符一般建议用public
   ps : 不能使用private和protected修饰接口
3. 常量 : 
   接口中的属性是常量, 即使定义时不添加 public static final 修饰符, 系统也会自动加上
4. 方法 : 
   接口中的方法只能是抽象方法, 即使定义时不添加public abstract 修饰符, 系统也会自动加上
5. 使用接口 : 
   一个类可以实现一个或者多个接口, 实现接口可以使用implements关键字. Java中的一个类只能继承一个父类,
   是不够灵活的, 通过实现过个接口可以做补充
   继承父类实现接口的语法为 : 
   [修饰符] class 类名 extends 父类 implements 接口1, 接口2...
   {
      类体部分  // 如果继承了抽象类, 需要实现继承的抽象方法; 要实现接口中的抽象方法
   }
   如果要继承父类, 继承父类必须在实现接口之前
使用接口 : 
   接口在使用过程当中, 还经常与匿名内部类配合使用
   匿名内部类就是没有名字的内部类
   多用于关注实现而不关注实现类的名称

</code></pre>
<h3 id="java中的内部类">Java中的内部类</h3>
<pre><code>1. 概念 : 
   内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类
2. 作用 : 
   1. 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
   2. 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
   3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便
3. 种类 : 
   成员内部类
   静态内部类
   方法内部类
   匿名内部类
PS : 
   1.外部类是不能直接使用内部类的成员和方法的
     可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。
   2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法
     如果要访问外部类的成员变量，可以使用 this 关键字。
Java 中的静态内部类
   静态内部类是 static 修饰的内部类，这种内部类的特点是：
      1.静态内部类不能直接访问外部类的非静态成员，但可以通过new 外部类().成员的方式访问 
      2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；
        如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员
      3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();
Java 中的方法内部类
   方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。
   ps : 由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。

</code></pre>
<h3 id="设计模式的三大分类">设计模式的三大分类</h3>
<p>设计模式是基于场景的解决方案</p>
<pre><code>1. 创建型模式

单例模式：某个类只能有一个实例，提供一个全局的访问点。（恶汉式线程安全，懒汉式存在线程风险）

简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。

工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。

抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。

建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。

原型模式：通过复制现有的实例来创建新的实例。


2. 结构型模式 
适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。

组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。

装饰模式：动态的给对象添加新的功能。

代理模式：为其他对象提供一个代理以便控制这个对象的访问。

亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。

外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。

桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。


3. 行为型模式
模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。

解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。

策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。

状态模式：允许一个对象在其对象内部状态改变时改变它的行为。

观察者模式：对象间的一对多的依赖关系。

备忘录模式：在不破坏封装的前提下，保持对象的内部状态。

中介者模式：用一个中介对象来封装一系列的对象交互。

命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。

访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。

责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。

迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
</code></pre>
<h3 id="相关资源">相关资源</h3>
<ul>
<li><code>http://www.runoob.com/java/java-interfaces.html</code></li>
<li><code>https://www.cnblogs.com/pony1223/p/7608955.html</code></li>
</ul>
]]></content>
    </entry>
</feed>