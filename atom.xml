<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://slowlog.github.io</id>
    <title>slowlog</title>
    <updated>2019-06-01T10:29:56.881Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://slowlog.github.io"/>
    <link rel="self" href="https://slowlog.github.io/atom.xml"/>
    <subtitle>slow life slow log.</subtitle>
    <logo>https://slowlog.github.io/images/avatar.png</logo>
    <icon>https://slowlog.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, slowlog</rights>
    <entry>
        <title type="html"><![CDATA[MySQL 学习笔记]]></title>
        <id>https://slowlog.github.io/post/mysql-xue-xi-bi-ji</id>
        <link href="https://slowlog.github.io/post/mysql-xue-xi-bi-ji">
        </link>
        <updated>2019-06-01T08:28:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="常用-sql-语句">常用 SQL 语句</h3>
<pre><code>#登陆
mysql -h host -u username -p

#列出所有数据库、选择数据库、列出所有表
show databases;
use database_name;
show tables;

#列出表结构
desc table_name;

#查看全局变量
show global variables;

#查看MySQL的字符集
show variables like'character%';

#修改运行时配置
set global variables_name=xxx;

#查看 MySQL 配置文件加载顺序
mysqld --help --verbose|grep -A 1 'Default options';

#创建数据库
CREATE DATABASE IF NOT EXISTS `db_name` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;

#创建用户及授权
CREATE USER 'username'@'host' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON `db_name`.* TO 'username'@'%';

说明:
- username 你将创建的用户名, 
- host 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%.  例: '192.168.1.%'
- password 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器. 

#更新权限
FLUSH PRIVILEGES;

#列出所有用户
SELECT User, Host FROM mysql.user;

#更新用户密码
update mysql.user set password (&gt;=5.7 authentication_string)=password('new_password') where User=&quot;test&quot;;

#删除用户
drop user username@'%';

#清空整张表
TRUNCATE TABLE `your_table_name`;

#变更字段值为另一张表的某个值
UPDATE `your_table_name` AS a JOIN `your_anther_table_name` AS b 
SET a.column = b.anther_column
WHERE a.id = b.a_id...;

#同一个实例下跨库查询
SELECT *
FROM database_name.your_table_name
AS a
JOIN another_database_name.your_another_table_name
AS b
WHERE a.column_name = b.column_name...;

#完全复制一张表：表结构+全部数据
CREATE TABLE `your_table_name`
LIKE `destination_table_name`;

INSERT INTO `your_table_name`
SELECT *
FROM `destination_table_name`;

</code></pre>
<h3 id="命名规范">命名规范</h3>
<pre><code>- 命名要做到见名知意，统一：mb_xxxx；表名不超过40个字符（即最大只能40个字符）
- 库名、表名、字段名、索引名必须使用小写字母；所有数据库对象名称，禁止使用MySQL保留关键字
- 所有的表和字段都要添加注释
- 临时库、表必须以tmp为前缀并以日期为后缀
- 备份库、表必须以bak为前缀并以日期为后缀
</code></pre>
<h3 id="表与字段规范">表与字段规范</h3>
<pre><code>- 所有表的DDL，都不回退
- 表一旦设计好， 字段只允许增加， 不允许减少（drop column）， 不允许改名称（change column）
- 禁止default NULL，数字类型not null default 0，字符类型not null default ''；
- 所有表必须有create_time和last_update_time，方便后期数据分析与记录变化排查，哪怕只是配置表，只有10行记录；
- 禁止在表中建立预留字段及在表中存储大的二级制数据
- 所有存储相同数据的列名与列类型必须一致(关联表)
- 非负型的数据优先使用无符号整型存储
- 存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE，如金额等
- 单表数据量的大小， 建议控制在500万以内， 为此设计阶段需考虑数据的归档

- 统一使用INNODB存储引擎， UTF8编码（整个数据库的编码统一为utf8_general_ci，为此不需要建立表的DDL加上特别CHARACTER SET utf8 COLLATE utf8_general_ci）

- 禁止使用 UUID()，USER()这样的MYSQL INSIDE函数对于复制来说是很危险的，会导致主备数据不一致，重要的是会严重影响mysql性能

- 表必须有主键，建议统一由Auto-Increment字段生成整型，不建议使用组合主键，自增id只作为虚拟主键，不建议与业务数据处理有关联关系，如果把控不好，会有问题

- 需在设计阶段考虑如果访问量非常大，且不做scale out表拆分的话，需读写分离，但读写分离注意主从复制有延迟的可能性

- 不要使用TEXT、BLOB、char，请使用VARCHAR(N)，N表示的是字符数不是字节数，比如VARCHAR(255)，可以最大可存储255个汉字，需要根据实际的宽度来选择N，请注意同一表中，所有varchar字段的长度加起来，不能大于65535。避免使用枚举(ENUM)类型

- 如果字段只有true or false，请使用tinyint（数值范围-128~127），如模块分类：1订单 2商品；删除标志 0正常，1删除；状态 1为可选，2为不可选等等
- 存储时间（精确到秒）建议使用TIMESTAMP类型，因为TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。

- 加字段禁止使用after，因为你不确定全局代码里面（如其他团队使用你的表）是否都insert into table（col，col，col。。。） value，如果你在中间插一个字段，就导致数据偏移的问题了，影响可大可小，同样select * 的也可能会影响数值的偏移

- 如果应用使用的是长连接，应用必须具有自动重连的机制。但请避免每执行一个SQL去检查一次DB可用性；应用应该具有连接的TIMEOUT检查机制，及时回收长时间没有使用的连接，TIMEOUT时间一般建议为20min

- 关键业务数据表，如订单表，用户信息表，钱包支付信息等，禁止硬删除，必须软删除，加上is_deleted字段，标注这条记录的状态。
</code></pre>
<h3 id="索引使用规范">索引使用规范</h3>
<pre><code>#索引列建议

- SELECT、UPDATE、DELETE 语句的WHERE从句中的列
- 包含在ORDER BY、GROUP BY、DISTINCT中的列
- 多表JOIN的关联列

#规范标准

- 非唯一索引建议使用“idx_表缩写名称_字段缩写名称”进行命名。
- 唯一索引建议使用“uniq_表缩写名称_字段缩写名称”进行命名。
- 索引名称必须_=BD_用小写。
- 唯一键不和主键重复。
- 索引字段的顺序需要考虑字段值去重之后的个数，个数多的放在前面，就是数据分布。
- 使用EXPLAIN判断SQL语句是否合理使用索引，尽量避免extra列出现：Using File Sort，Using Temporary。
- UPDATE、DELETE语句需要根据WHERE条件添加索引。
- 合理创建联合索引（避免冗余），(a，b，c) 相当于 (a) 、(a，b) 、(a，b，c)。
- 合理利用覆盖索引。比如SELECT email，uid FROM user_email WHERE uid=xx，如果uid不是主键，适当时候可以将索引添加为index(uid，email)，以获得性能提升。
</code></pre>
<h3 id="约束设计规范">约束设计规范</h3>
<pre><code>- 主键的内容不能被修改。
- 外键约束一般不在数据库上创建，只表达一个逻辑的概念，由程序控制。
- 禁用数据库外键
#命名
- 主键约束：默认PRIMARY；
- unique约束：UK_&lt;column_name&gt;
- check约束： CK_&lt;column_name&gt;
- 外键约束： 业务禁用
</code></pre>
<h3 id="sql-语句规范">SQL 语句规范</h3>
<pre><code>- 禁止使用子查询，select col、col from table where id in （select col from table）这是禁止的

- 多表join的时候，写SQL的时候一定要给每个字段指定表名做前缀；如: select a.id，a.name from test1 a， test2 b where a.id=b.id

- 尽量用单表查询，避免多表JOIN，禁止多于3表join，join的字段数据类型必须绝对一致

- 使用prepared statement，可以提供性能并且避免SQL注入。

- SELECT语句只获取需要的字段，禁止使用SELECT * FROM语句，这是有效防止新增字段对应用逻辑的影响，还能减少对性能的影响

- INSERT语句必须显式的指明字段名称，不使用INSERT INTO table value()

- 禁止在where子句中对字段施加函数，如to_date（add_time)&gt;xxxxx，应改为:add_time &gt;= unix_timestamp(date_add(str_to_date('20130227'，'%Y%m%d')，interval - 29 day))

- 写到应用程序里的SQL语句，禁止一切DDL操作，如对这些权限有要求，必需与DBA协商同意方可使用

- WHERE条件中必须使用合适的类型，避免MySQL进行隐式类型转化，如ISENDED=1，字段类型是tinyint，那么不能是ISENDED=‘1’

- 避免在SQL语句进行数学运算或者函数运算，容易将业务逻辑和DB耦合在一起。

- 避免使用存储过程、触发器、函数等，容易将业务逻辑和DB耦合在一起，并且MySQL的存储过程、触发器、函数中存在一定的bug。

- 使用合理的SQL语句减少与数据库的交互次数。

- 不使用ORDER BY RAND()，使用其他方法替换。

- 建议使用合理的分页方式以提高分页的效率。

- InnoDB表避免使用COUNT(*)操作，计数统计实时要求较强可以使用memcache或者redis，非实时统计可以使用单独统计表，定时更新。

- 不建议使用%前缀模糊查询，例如LIKE “%weibo”。

- 避免多余的排序。使用GROUP BY 时，默认会进行排序，当你不需要排序时，可以使用order by null，例如Select a.OwnerUserID，count(*) cnt from DP_MessageList a group by a.OwnerUserID order by null；

- 新增排序要求：不鼓励在DB里排序，特别是只有1000行一下的，请在app server上排序，app server有上百台，而db仅仅个位数的服务器数量，排序都在db，会把db压垮的，特别是禁止上千行的排序在db这边。
</code></pre>
<h3 id="主从复制">主从复制</h3>
<h4 id="工作原理概述">工作原理概述</h4>
<ol>
<li>主库将变更写入到主库的 binlog 中</li>
<li>从库的 IO 进程从指定的位置读取主库 binlog 内容存储到从库 Relay Log 日志中</li>
<li>从库的 SQL 进程读取 Relay Log 日志中内容在从库中重放</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/16852041/33526576-a4df45a0-d87e-11e7-903f-fa8794a94384.png" alt="0_1330439010p7li"></p>
<h4 id="配置步骤">配置步骤</h4>
<h4 id="方式一-基于二进制日志点">方式一、基于二进制日志点</h4>
<pre><code>1. 配置主从数据库服务器参数
#主服务器配置
log_bin=/data/mysql/sql_log/mysql-bin
server-id = 100 (192.168.1.100, 值为ip地址最后一段)
#注: UUID 值如果相同, 主从复制会出现问题, 删除 data 目录下的 auto.cnf 即可

#从服务器配置
log_bin=/data/mysql/sql_log/mysql-bin
server-id = 101 (192.168.1.101, 值为ip地址最后一段)
relay_log= /data/mysql/sql_log/relay-log
read_only=on
super_read_only=on (MySQL&gt;=5.7)
skip_slave_start=on
master_info_repository=TABLE
relay_log_info_repository=TABLE

2. 在主服务器上创建数据库账号 ( 用于从服务器IO进程连接获取 binlog ), 需要 REPLICATION SLAVE 权限

CREATE USER 'repl'@'IP段' identified by 'password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'IP段';

3. 备份主服务器上的数据并在从服务器上恢复

- 建议主从数据库采用相同的MySQL版本  (注意: 如不相同,则主服务器的版本一定要低于从服务器)
- 建议使用全库备份的方式初始化 Slave 上的数据

#主服务器备份
mysqldump  -uroot -p --master-data -A  --single-transaction -R --triggers  &gt; all.sql
#拷贝到从服务器
scp all.sql root@192.168.1.101:/root
#从服务器恢复
mysql -uroot - p &lt; all.sql

4. 启动复制链路 (从服务器执行)
mysql&gt; CHANGE MASTER TO MASTER_HOST='192.168.1.100',
    -&gt; MASTER_USER='repl',
    -&gt; MASTER_PASSWORD='password',
    -&gt; MASTER_LOG_FILE='mysql_log_file_name', // 从主服务器备份文件中获取
    -&gt; MASTER_LOG_POS=xxx; // 从主服务器备份文件中获取
mysql&gt; start slave;  //启动
mysql&gt; show slave status \G // 查看状态

</code></pre>
<h4 id="方式二-基于gtid-全局事务id">方式二、基于GTID (全局事务ID)</h4>
<pre><code>#在主库从库设置 gtid 模式
#设置gtid模式，在my.cnf里面的mysqld选项卡里面设置，设置完后，重启mysql服务生效
gtid_mode=on
enforce-gtid-consistency=on
log-slave-updates=on (MySQL &gt;=5.7 则可以不启用)

#从服务器启动复制链路
mysql&gt; CHANGE MASTER TO MASTER_HOST='master_host_ip',
    -&gt; MASTER_USER='repl',
    -&gt; MASTER_PASSWORD='password',
    -&gt; MASTER_AUTO_POSITION = 1
</code></pre>
<h4 id="利用-keepalived-实现双主复制-主主复制">利用 keepalived 实现双主复制 (主主复制)</h4>
<p>虚拟IP (vip)
就是一个未分配给真实主机的ip,也就是说对外提供服务的主机除了有一个真实ip外还有一个虚拟ip</p>
<p>如下图所示 :</p>
<p><img src="https://user-images.githubusercontent.com/16852041/33527743-fc97c38c-d890-11e7-9ded-b7f6ebffdb21.png" alt="qq 20171204011725"></p>
<h4 id="主主复制配置变更">主主复制配置变更</h4>
<pre><code>#主数据库配置修改 (my.cnf)
auto_increment_increment=2
auto_increment_offset=1  // 1,3,5,7,9... 

#从数据库配置修改
auto_increment_increment=2
auto_increment_offset=2 // 2,4,6,8, 10...

#查看当前状态
mysql &gt; show master status \G

#主服务器启用复制链路
#由于是主主复制, 所以把当前的主库当做从库, 当前的从库当做主库
mysql &gt; change master to master_host='192.168.1.101',
          &gt; master_user='repl', // 由于之前从服务器初始化了主库的数据, 所以从库也有这个用户
          &gt; master_password='password',
          &gt; master_log_file='从服务器的二进制日志',
          &gt; master_log_pos='从服务器的二进制日志点';

mysql &gt; start slave;
mysql &gt; show slave status \G

</code></pre>
<h4 id="keepalived-安装-主和主备服务器都要安装">keepalived 安装 (主和主备服务器都要安装)</h4>
<pre><code>#yum源安装
yum install keepalived –y

#源码安装
#下载指定版本
wget http://www.keepalived.org/software/keepalived-1.2.20.tar.gz                  
#解压缩安装
tar -xvf keepalived-1.2.20.tar.gz
cd keepalived-1.2.20
yum install openssl* -y
./configuremakemake install

#配置文件路径  
/etc/keepalived/keepalived.conf

#启动 keepalived
/etc/init.d/keepalived start

- 具体配置参考 http://blog.csdn.net/hzsunshine/article/details/67059532
</code></pre>
<h3 id="性能优化">性能优化</h3>
<h4 id="服务器硬件和系统的选择">服务器硬件和系统的选择</h4>
<pre><code>#CPU
- 64位的cpu一定要工作在64的系统下
- 对于并发比较高的场景cpu的数量比频率重要
- 对于cpu密集性场景和复杂SQL则频率越高越好
#内存
- 选择主板所能使用的最高频率的内存
- 内存的大小对性能很重要, 所以尽可能的大
#I/O子系统
- PCIe -&gt; SSD -&gt; Raid10 -&gt; HHD -&gt; (SAN/NAS)
`SAN一般用于数据备份`
</code></pre>
<h4 id="centos-系统参数优化">CentOS 系统参数优化</h4>
<pre><code>#内核相关参数(/etc/sysctl.conf)，以下参数根据需求调整
net.core.somaxconn = 65535
net.core.netdev_max_backlog = 65535
net.ipv4.tcp_max_syn_backlog = 65535

net.ipv4.tcp_fin_timeout = 10

net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1 

net.core.wmen_default = 87380
net.core.wmen_max = 16777216
net.core.rmen_default = 87380
net.core.rmen_max = 16777216

net.ipv4.tcp_keepalive_time = 120
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 3

#linux内核参数中最重要的参数之一,用于定义单个共享内存段的最大值
kernel.shmmax = 4294967295
1.这个参数应该设置的足够大, 以便能在一个共享内存段下容纳整个的Innodb缓冲池的大小
2. 这个值的大小对于64位linux系统,可取的最大值为物理内存值减1byte, 一般取值大于Innodb缓冲池的大小即可

#当内存不足时会对性能产生比较明显的影响
vm.swappiness = 0 

#增加资源限制(/etc/security/limits.conf)
* soft nofile 65535
* hard nofile 65535
// ---------------------------
*          表示对所有用户有效
soft     指的是当前系统生效的设置
hard    表明系统中所能设定的最大值
nofile  表示所限制的资源是打开文件的最大数目
65535 限制的数量

#改变磁盘调度策略
echo deadline &gt; /sys/block/sda/queue/scheduler

#文件系统建议使用 XFS
</code></pre>
<h4 id="数据库存储引擎和参数配置">数据库存储引擎和参数配置</h4>
<h5 id="常用的存储引擎">常用的存储引擎</h5>
<pre><code>- MyISAM (5.5之前版本默认存储引擎)
&gt; 适用场景: 1. 非事务型应用  2. 只读类应用(表中绝大部分都是查询操作)

- Innodb (5.5之后版本默认存储引擎)
&gt; 适用场景: 大多数OLTP应用

- CSV ( 以csv格式进行存储数据)
&gt; 适用场景: 数据交换的中间表 

- Archive (只支持insert和select操作)
&gt; 适用场景: 日志和数据采集类应用

- Memory(所有数据保存在内存中)
&gt; 适用场景: 映射表或缓存周期性聚合数据的结果表

`参考: http://blog.csdn.net/lc0817/article/details/52757194`
</code></pre>
<h4 id="mysql-参数配置">MySQL 参数配置</h4>
<pre><code>#内存相关配置参数
sort_buffer_size
join_buffer_size
read_buffer_size
read_rnd_buffer_size
Innodb_buffer_pool_size
key_buffer_size

# IO相关配置参数
#innodb引擎
Innodb_log_file_size
Innodb_log_files_in_group
Innodb_log_buffer_size
Innodb_flush_log_at_trx_commit = 2
Innodb_flush_method = O_DIRECT
Innodb_file_per_table = 1
Innodb_doublewrite = 1

#安全相关配置参数
expire_logs_days
max_allowed_packet
skip_name_resolve
sysdate_is_now
read_only (从库中启用)
skip_slave_start (从库中禁用)
sql_mode

#其他常用配置参数
sync_binlog
tmp_table_size 和 max_heap_table_size 一起使用,值保持一致
max_connections (控制允许的最大连接数)

</code></pre>
<h4 id="数据库表结构设计和sql语句的优化-重点">数据库表结构设计和SQL语句的优化 (重点)</h4>
<h4 id="如何实现读写分离">如何实现读写分离</h4>
<h5 id="方式一">方式一</h5>
<pre><code>- 由开发人员根据所执行的SQL类型连接不同的数据库服务器

优点:  完全由开发人员控制, 实现灵活, 由程序直接连接数据库, 性能损耗少,
缺点:  增加了开发工作量, 使程序代码更加复杂, 人为控制容易出错
</code></pre>
<h5 id="方式二">方式二</h5>
<pre><code>- 由数据库中间层(代理层) 来完成  ( 如: mysql proxy、maxscale、one proxy、proxySQL)

优点:  由中间件根据查询语法分析, 自动完成读写分离,  对程序透明,  对已有程序不用做任何调整
缺点:  查询效率有非常严重的损耗,  对于延迟敏感业务无法自动在主库上执行
</code></pre>
<h4 id="读服务器负载均衡方式">读服务器负载均衡方式</h4>
<ul>
<li>数据库中间层</li>
<li>DNS 轮询 (性能较差)</li>
<li>LVS / Haproxy  (推荐)</li>
<li>硬件 F5</li>
</ul>
<h4 id="分库分表的几种方式">分库分表的几种方式</h4>
<ul>
<li>
<p>把一个实例中的多个数据库拆分到不同的实例
<img src="https://user-images.githubusercontent.com/16852041/33559540-1b072896-d948-11e7-94ce-a057a21c0e06.png" alt="qq 20171204230829"></p>
</li>
<li>
<p>把一个库中的表分离到不同的数据库中
<img src="https://user-images.githubusercontent.com/16852041/33559557-2409d5ba-d948-11e7-9bbe-840adf3e2ede.png" alt="2"></p>
</li>
<li>
<p>(慎用!)对一个库中的相关表进行水平拆分到不同实例的数据库中 (数据库分片)
<img src="https://user-images.githubusercontent.com/16852041/33559770-d64e4e2c-d948-11e7-91a4-b016d9fe88d2.png" alt="3"></p>
</li>
</ul>
<h3 id="备份相关">备份相关</h3>
<h4 id="逻辑备份和物理备份">逻辑备份和物理备份</h4>
<ul>
<li>逻辑备份的结果为 sql 语句, 适合于所有存储引擎</li>
<li>物理备份是对数据库目录的拷贝, 对于内存表只备份结构</li>
</ul>
<h4 id="全量备份和增量备份">全量备份和增量备份</h4>
<ul>
<li>全量备份是对整个数据库的一个完整备份</li>
<li>增量备份是在上次全量或增量备份基础上, 对于更改数据进行的备份</li>
</ul>
<h4 id="mysqldump-备份工具">mysqldump 备份工具</h4>
<h5 id="常用参数说明">常用参数说明</h5>
<pre><code>-u 用户名
-p 密码
-h 备份主机名,默认 localhost
-P 端口
--all-databases, -A  备份所有数据库
--force, -f  即使发现sql错误，仍然继续备份
--no-data, -d  只导出表结构
--quick, -q  快速导出
--events, -E 调度事件
--triggers 触发器, 该选项默认启用，用--skip-triggers禁用它
--lock-all-tables, -x  锁住一个实例下所有数据库中的所有表
--where='condition'   指定过滤条件, 只支持单表数据导出
--routines, -R 存储过程以及自定义函数
--xml, -X  导出为xml文件

--lock-tables , -l  
锁住当前数据库下所有的表, 只允许读操作 一般用于 MyISAM 存储引擎, 对于 INNODB 存储引擎则不需要使用, 当数据库中同时存在 MyISAM 和 INNODB 时, 则使用该项 

--single-transaction 
启动一个事务, 用于保证数据的一致性, 只对 INNODB 存储引擎有效

--master-data=[1或2] 
该选项将binlog的位置和文件名追加到输出文件中。如果为1, 将会输出CHANGE MASTER 命令；如果为2, 输出的CHANGE  MASTER命令前添加注释信息, 默认值是1

--hex-blob 
以16进制导出blob字段数据。同版本下不加此参数一般不会有什么问题，但在不同 MySQL 版本间最好加此参数

--tab=path
这个选项将会创建两个文件，一个是带分隔符的文本文件，备份的数据表中的每行存储为文本中的一行，以“表名.txt”保存；另一个输出文件为数据表的CREATE TABLE语句，以“表名.sql”保存。

--databases, -B
用于备份多个数据库，如果没有该选项，mysqldump 把第一个名字参数作为数据库名，后面的作为表名。使用该选项，mysqldump 把每个名字都当作为数据库名。

</code></pre>
<h4 id="导出">导出</h4>
<pre><code>#导出数据库为 test 下面表名为 b 的数据
mysqldump -uroot -h 127.0.0.1  test b &gt; b_bak.sql
 
#导出数据库为 test 的所有数据
mysqldump -uroot -h 127.0.0.1 test &gt;bak.sql
 
#导出数据库名为test和 test1 的数据库
mysqldump -uroot -h 127.0.0.1  -B test test1 &gt; /data/bak.sql
 
#导出所有的数据库
mysqldump -uroot -h 127.0.0.1 -A &gt; /data/all.sql
 
#导出数据库的结构
mysqldump -uroot -h 127.0.0.1  test b  -d&gt; b_test.sql 
</code></pre>
<h4 id="导入">导入</h4>
<pre><code>#mysql命令行导入
mysql&gt; source /data/test.sql
#还原单个数据库（需指定数据库）
mysql&gt; use test
mysql&gt; source /data/test.sql

#系统命令行导入
mysql -uroot -p &lt;/data/test.sql
#还原多个数据库（不需要指定数据库）
mysql -uroot -p &lt;/data/all.sql
</code></pre>
<h4 id="xtrabackup-备份工具">XtraBackup 备份工具</h4>
<h5 id="简介">简介</h5>
<p>xtrabackup是Percona公司CTO Vadim参与开发的一款基于InnoDB的在线热备工具，具有开源、免费、支持在线热备、备份恢复速度快、备份过程中, 不会影响表的读写操作、占用磁盘空间小等特点，并且支持不同情况下的多种备份形式。</p>
<h5 id="官方下载">官方下载</h5>
<p><code>https://www.percona.com/downloads/XtraBackup/LATEST/</code></p>
<h5 id="安装教程">安装教程</h5>
<p><code>http://www.linuxidc.com/Linux/2017-06/144817.htm</code></p>
<h4 id="备份脚本">备份脚本</h4>
<pre><code>#!/bin/bash
###############Basic parameters##########################
DAY=`date +%Y%m%d`
Environment=$(/sbin/ifconfig | grep &quot;inet addr&quot; | head -1 |grep -v &quot;127.0.0.1&quot; | awk '{print $2;}' | awk -F':' '{print $2;}')
USER=&quot;backup&quot;
PASSWD=&quot;123456&quot;
HostPort=&quot;3306&quot;
MYSQLBASE=&quot;/home/mysql/&quot;
DATADIR=&quot;/home/db_backup/${DAY}&quot;
MYSQL=`/usr/bin/which mysql`
MYSQLDUMP=`/usr/bin/which mysqldump`
mkdir -p ${DATADIR}

Dump(){
 ${MYSQLDUMP} --master-data=2 --single-transaction  --routines --triggers --events -u${USER} -p${PASSWD} -P${HostPort} ${database}  &gt; ${DATADIR}/${Environment}-${database}.sql
 cd ${DATADIR}
 gzip ${Environment}-${database}.sql
}

for db in `echo &quot;SELECT schema_name FROM information_schema.schemata where schema_name not in ('information_schema','sys','performance_schema')&quot; | ${MYSQL} -u${USER} -p${PASSWD} --skip-column-names`
do
   database=${db}
   Dump
done
</code></pre>
<h4 id="docker-mysql-备份">docker mysql 备份</h4>
<pre><code>#备份脚本
#!/bin/bash
docker_container_name=mysql_mysql_1
data_dir=&quot;/data/backups&quot;
docker exec -it ${docker_container_name} mysqldump -uroot -p**** --all-databases &gt; &quot;$data_dir/data_`date +%Y%m%d`.sql&quot;
if [ $? -ne 0 ];then
    # 任务失败，发送邮件
    echo -e &quot;mysql备份失败&quot; | mail -s '备份任务失败' xxxx@163.com
    exit -1
fi
find $data_dir -mtime +7 -name 'data_[1-9].sql' -exec rm -rf {} \;
  
  
#定时任务
0 2 * * * sh /sh/mysql-bak.sh &gt; /data/docker/mysql/mysql_bak.log 2&gt;&amp;1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx 学习笔记]]></title>
        <id>https://slowlog.github.io/post/nginx-xue-xi-bi-ji</id>
        <link href="https://slowlog.github.io/post/nginx-xue-xi-bi-ji">
        </link>
        <updated>2018-09-15T08:16:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="nginx-特性">Nginx 特性</h3>
<ul>
<li>IO 多路复用epoll</li>
<li>轻量级，功能模块少，代码模块化</li>
<li>CPU（affinity）</li>
<li>sendfile</li>
</ul>
<h3 id="nginx-安装">Nginx 安装</h3>
<pre><code># 设置nginx的yum源
vim /etc/yum.repos.d/nginx.repo

[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1

# 列出nginx源
yum list | grep nginx

# 安装
yum install -y nginx

# 查看版本
nginx -v

# 查看安装的编译参数
nginx -V
2&gt;&amp;1 nginx -V | tr ' ' '\n'|grep ssl

# 查看安装目录
rpm -ql nginx

</code></pre>
<h3 id="nginx-目录">Nginx 目录</h3>
<pre><code># nginx日志轮转，用于logrotate服务的日志切割
/etc/logrotate.d/nginx

# 主配置文件
/etc/nginx/nginx.conf

# cgi，fastcgi 配置文件
/etc/nginx/fastcgi_params
/etc/nginx/uwsgi_params
/etc/nginx/scgi_params

# http协议的Content-Type与扩展名对应关系
/etc/nginx/mime.types

# nginx模块目录
/usr/lib64/nginx/modules
/etc/nginx/modules

# nginx缓存目录
/var/cache/nginx

# nginx日志目录
/var/log/nginx

</code></pre>
<h3 id="nginx-编译参数">Nginx 编译参数</h3>
<pre><code># 设置安装目录与路径
--prefix=/etc/nginx
--sbin-path=/usr/sbin/nginx
--modules-path=/usr/lib64/nginx/modules
--conf-path=/etc/nginx/nginx.conf
--error-log-path=/var/log/nginx/error.log
--http-log-path=/var/log/nginx/access.log
--pid-path=/var/run/nginx.pid
--lock-path=/var/run/nginx.lock

# 设置nginx进程启动的用户与用户组
--user=nginx
--group=nginx

# 开启支持https请求，需已安装openssl
--with-http_ssl_module
# 开启gzip支持
--with-http_gzip_static_module
# 开启ipv6支持
--with-ipv6

</code></pre>
<h3 id="nginx-配置文件详解">Nginx 配置文件详解</h3>
<pre><code>user  nginx; #设置nginx服务运行时用户
worker_processes  1; #工作进程数,通常设置成和cpu的核数相等

error_log  /var/log/nginx/error.log warn; #错误日志
pid        /var/run/nginx.pid; #nginx服务启动时pid


events {
    worker_connections  1024; #每个进程允许处理的最大连接数
    use   epoll; #设置nginx使用什么内核模型，epoll仅用于linux2.6以上内核,可以大大提高nginx的性能
}


http {
    #设置mime类型,类型由mime.type文件定义
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    #设置日志格式（nginx内置变量，可自定义变量）
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    #访问日志
    access_log  /var/log/nginx/access.log  main;

    #启用高效传输文件的模式  
    sendfile        on;
    #tcp_nopush     on; #必须和sendfile搭配使用

    #连接超时时间
    keepalive_timeout  65;

    #gzip压缩相关（相对来说对文本的压缩效率是最高的）
    gzip  on;
    gzip_http_version 1.1;
    gzip_comp_level 2;
    gzip_types text/css image/jpeg image/png image/gif;

    #设置请求缓冲
    client_header_buffer_size    128k;
    large_client_header_buffers  4 128k;

    server {
    #监听端口
    listen       80;
    #定义使用 www.baidu.com访问
    server_name  www.baidu.com;

    #访问日志
    access_log  /var/log/nginx/host.access.log  main;

    #监听nginx当前的连接信息
    location /my_stub {
      stub_status;
    }

    #默认请求
    location / {
        #网站默认根目录位置
        root html;

        #定义首页索引文件的名称
        index index.php index.html index.htm;
    }

    #定义错误提示页面
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    #静态文件nginx自己处理
    location ~ ^/(images|javascript|js|css|flash|media|static)/ {
        #设置静态文件的过期时间
        expires 7d;

        #防盗链配置
        valid_referers none blocked 192.168.1.102
        if ($invalid_referer){
          return 403;
        }
        root /www/images;
    }

    #PHP脚本请求全部转发到FastCGI处理
    location ~ \.php$ {
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        include        fastcgi_params;
    }

}
    #引入其他server
    #include /etc/nginx/conf.d/*.conf;
}

</code></pre>
<h3 id="访问控制">访问控制</h3>
<pre><code>http{

  # 跨域相关配置
  add_header 'Access-Control-Allow-Origin' '*';
  add_header 'Access-Control-Allow-Headers' 'X-Requested-With';
  add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS';

  #连接限制
  limit_conn_zone $binary_remote_addr zone=conn_zone:1m;
  #请求限制
  limit_req_zone $binary_remote_addr zone=req_zone:1m rate=1r/s;

  server{

    location / {

      #内容替换,默认匹配第一个，设置为off则匹配所有
      #sub_filter '&lt;a&gt;baidu&lt;/a&gt;' '&lt;p&gt;BAIDU&lt;/p&gt;';
      #sub_filter_once off;

      #启用随机主页
      #random_index on;    

      #启用连接限制(参考http模块配置的空间)
      limit_conn conn_zone 1;
      #启用请求限制(参考http模块配置的空间)
      limit_req zone=req_zone burst=3 nodelay;

      #限制指定ip不允许访问（反之则允许指定ip访问）
      deny 192.168.1.102;
      allow all;

      #用户认证配置
      auth_basic &quot;please input your pwd!&quot;;
      auth_basic_user_file /path/htpasswd/auth_file;
    }

    #禁止访问 .htxx 文件
    location ~ /\.ht {
        deny  all;
    }
  }
}

</code></pre>
<h3 id="负载均衡">负载均衡</h3>
<pre><code>http{

  upstream your_server_name {
    server 127.0.0.1:8001 weight=5;
    server 127.0.0.1:8002 backup;
    server 127.0.0.1:8003 max_fails=1 fail_timeout=10;

    #可通过iptables策略测试以下配置
    #backup 备份服务器
    #max_fails 允许请求失败的次数
    #fail_timeout 经过max_fails失败后，服务暂停的时间
    #max_conns 最大连接数
    #weight 加权轮询weight值越大，分配到的访问几率越高
    #ip_hash 每个请求按访问IP的hash结果分配，一个IP固定到一个后端服务器，
    #url_hash 每个请求按访问url的hash结果分配
    #least_conn 哪个机器连接数少，就分配到哪个，类似加权轮询
  }

  server{

    location / {
        proxy_pass http://your_server_name;
        include proxy_params;
    }
  }
}
</code></pre>
<h3 id="rewrite规则">Rewrite规则</h3>
<pre><code>break 使用break会停止匹配下面的location，直接发起请求www.xxx.com/test/,然而root目录下没有test这个目录，所以404
last  停止当前这个请求，并根据rewrite匹配的规则重新发起一个请求，重写后的规则，会继续用重写后的值去匹配下一个的location
redirect 返回302临时重定向
permanent 返回301永久重定向（浏览器会保留永久重定向的结果，不会再向服务端发起请求）
server{
    root /www;
    # url重写
    location / {
       rewrite ^/course-(\d+)-(\d+)-(\d+)\.html$ /course/$1/$2/course_$3.html break;

      #如果是谷歌浏览器打开的则重定向到指定位置  
       if ($http_user_agent ~* Chrome) {
           rewrite ^/nignx http://www.baidu.com/nginx/index.html redirect;
       }
       #如果访问的路径不存在，则转发到指定位置
       if (!-f $request_filename) {
          rewrite ^/(.*)$ http://www.baidu.com/$1 redirect;
       }

      index index.html index.htm;
    }
    location ~ ^/break {
       rewrite ^/break /test/ break;
    }
    location ~ ^/last {
       rewrite ^/last /test/ last;
    }
    location /test/ {
       default_type application/json;
       return 200 '{&quot;status&quot;:&quot;success&quot;}';
    }
}
</code></pre>
<h3 id="nginx安全下载模块">nginx安全下载模块</h3>
<pre><code>location / {
    secure_link $arg_md5,$arg_expires;
    secure_link_md5 &quot;$secure_link_expires$uri xxxx(自定义key)&quot;;

   if ($secure_link = &quot;&quot;) {
     return 403;
   }
   if ($secure_link = &quot;0&quot;){
      return 410;
   }
}

需生成如下请求下载示例：
http://www.xxxx.com/download/xxx.jpg?md5=xxxx&amp;expires=1587845

</code></pre>
<h3 id="nginx-geoip模块">nginx geoip模块</h3>
<pre><code>基于GeoIP MaxMind
#主要使用场景
1.区别国内外作http访问规则
2.区别国内城市地域作http访问规则

#安装
yum install -y nginx-module-geoip

#GeoIP库
mkdir /etc/nginx/geoip &amp;&amp; cd /etc/nginx/geoip
wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz
wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz
参考：http://www.52os.net/articles/configure-nginx-using-geoip-allow-whitelist.html

#解压
gunzip GeoLiteCity.dat.gz GeoIP.dat.gz

vim /etc/nginx/nginx.conf

#加载模块
load_module &quot;modules/ngx_http_geoip_module.so&quot;;
load_module &quot;modules/ngx_stream_geoip_module.so&quot;;

http{

  #读取GeoIP库文件
  geoip_country /etc/nginx/geoip/GeoIP.dat;
  geoip_city /etc/nginx/geoip/GeoLiteCity.dat;


  server{

    location / {
      # 拒绝国外ip访问
      if ($geoip_country_code != CN) {
            return 403;
      }
    }
    #测试获取自己的出口ip
    location /myip {
       default_type application/json;
       return 200 '{&quot;ip&quot;:&quot;$remote_addr&quot;,&quot;country&quot;:&quot;$geoip_country_name&quot;,&quot;country_code&quot;:&quot;$geoip_country_code&quot;,&quot;city&quot;:&quot;$geoip_city&quot;}';
   }

  }

}

</code></pre>
<h3 id="获取用户真实ip地址">获取用户真实ip地址</h3>
<ul>
<li>当存在多级代理的情况下，可通过第一级代理设置头信息传递给后端服务</li>
</ul>
<h3 id="nginx-常见错误码">Nginx 常见错误码</h3>
<ul>
<li>403 forbidden #权限问题</li>
<li>404 not found #文件没找到</li>
<li>413 request entity too large #用户上传的文件超过限制</li>
<li>502 bad gateway #后端服务无响应</li>
<li>504 gateway time-out #后端服务执行超时</li>
</ul>
<h3 id="ab压力测试工具">ab压力测试工具</h3>
<pre><code>yum install -y httpd-tools

ab -n 2000 -c 2 http://127.0.0.1/
-n 总的请求数
-c 并发数
-k 是否开启长连接
</code></pre>
<h3 id="系统与-nginx-性能优化">系统与 nginx 性能优化</h3>
<h4 id="文件句柄">文件句柄</h4>
<pre><code>linux 一切皆文件，当每一次用户发起一个请求就会产生一个文件句柄，文件句柄就是一个索引。

#设置方式
- 系统全局性修改
- 用户局部性修改
- 进程局部性修改

vim /etc/security/limits.conf

#root用户
root soft nofile 65535
root hard nofile 65535
#所有用户
*    soft nofile 25535
*    hard nofile 25535
#针对进程
vim /etc/nginx/conf/nginx.conf
worker_rlimit_nofile 15535;(小站点建议1w以上，大站点3w以上)

</code></pre>
<h4 id="cpu亲和性配置">cpu亲和性配置</h4>
<pre><code>#查看当前物理cpu个数
cat /proc/cpuinfo | grep &quot;physical id&quot;|sort|uniq|wc -l

#查看当前单个cpu的核心
cat /proc/cpuinfo | grep &quot;cpu cores&quot;|uniq

#nginx配置
worker_processes 2;（建议配成cpu虚拟核心的个数）
worker_cpu_affinity auto;

# 查看当前nginx进程cpu使用情况
ps -eo pid,args,psr|grep [n]ginx

</code></pre>
<h4 id="通用配置">通用配置</h4>
<pre><code>error_log /var/log/nginx/error.log warn;

events{
  use epoll;
  worker_connections 10240;
}

http{
    charset utf-8;
    access_log /var/log/nginx/access.log main;
}


</code></pre>
<h3 id="nginx安全策略">nginx安全策略</h3>
<h4 id="文件上传漏洞">文件上传漏洞</h4>
<pre><code>location ^~ /upload {
  root /opt/app/images;
  if ($request_filename ~* (.*)\.php) {
      return 403;
  }
}
</code></pre>
<h4 id="基于lua-nginx-moduleopenresty的web应用防火墙">基于lua-nginx-module(openresty)的web应用防火墙</h4>
<p><code>https://github.com/loveshell/ngx_lua_waf</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker 学习笔记]]></title>
        <id>https://slowlog.github.io/post/docker-xue-xi-bi-ji</id>
        <link href="https://slowlog.github.io/post/docker-xue-xi-bi-ji">
        </link>
        <updated>2017-11-01T08:27:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="初识-docker">初识 docker</h3>
<p>docker 是一项可以将应用及其依赖打包成一个容器进行分发、从而保证环境一致性的技术，采用 Go 开发，于 2013 年初由 docker.Inc 发布。docker 的出现使软件开发及部署流程变得更为简洁与规范。</p>
<h3 id="docker-特点">docker 特点</h3>
<p><strong>轻型</strong> docker 容器间共享服务器的系统库、系统工具、运行环境及代码，这样便能够保证运行一致性。</p>
<p><strong>开源</strong> docker 容器基于一系列开源标准，运行于所有的主流 Linux 操作系统。</p>
<p><strong>安全</strong> 容器间的应用相互隔离，底层基础设施为其提供了一层额外保护。</p>
<h3 id="部署流程">部署流程</h3>
<p><img src="https://user-images.githubusercontent.com/16852041/28628145-62dad7c0-7256-11e7-8c4a-bb328bb836cc.png" alt="b5bbc6c76f197902"></p>
<h3 id="docker-的安装">docker 的安装</h3>
<pre><code>1. 安装必要的一些系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2

2. 添加软件源信息
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

3. 安装 docker-ce
sudo yum makecache fast
sudo yum -y install docker-ce

4. 启动 docker 服务
sudo service docker start

5. docker 加速器
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
  &quot;registry-mirrors&quot;: [&quot;https://6ty2vtn5.mirror.aliyuncs.com&quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<h3 id="docker-常用命令">docker 常用命令</h3>
<pre><code>#从 registry 拉取 image
docker pull  

#推送 image 到 registry
docker push  

#开启/停止/重启 container
docker start/stop/restart  

#默认显示正在运行中的 container
docker ps  

#显示最后一次创建的 container, 包括未运行的  
docker ps -l 

#显示所有的 container, 包括未运行的
docker ps -a 

#删除一个或多个 container
docker rm containerId  

#删除一个或多个 image
docker rmi imageId     

#进入container bash
docker exec -it containerId bash 

#列出所有的 images
docker images -a  

#创建网关
docker network create &lt;name&gt;

#列出所有网关
docker network ls

#创建 container 并将 container 的端口映射到宿主机的端口
docker run -i -t -p hostport:containerport image

#寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的 image
docker build

# 查看 docker 的版本号，包括客户端、服务端、依赖的 Go 等
docker version 

# 将容器做成镜像
docker commit -m  &quot;提示信息&quot;   -a  &quot;作者&quot;   容器ID  镜像名称

# 移除已退出的容器并删除 id 为&lt;None&gt;的 image
docker ps -a | grep &quot;Exited&quot; | awk '{print $1 }'|xargs docker rm
docker rmi $(docker images -a | grep &quot;^&lt;none&gt;&quot; | awk &quot;{print $3}&quot;)

</code></pre>
<blockquote>
<p>注: 容器内可以使用 <code>ping 容器名</code>  来查看是否在同一局域网内, 当挂载目录出现权限问题时, 应检查宿主机与容器的用户与组的id是否一致</p>
</blockquote>
<h3 id="dockerfile-设置时区">dockerfile 设置时区</h3>
<pre><code># 方式一
ENV TZ=Asia/Shanghai
RUN ln -sf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone

# 方式二
RUN apk --update add tzdata \
&amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[个人书签&收藏]]></title>
        <id>https://slowlog.github.io/post/ge-ren-shu-qian-andshou-cang</id>
        <link href="https://slowlog.github.io/post/ge-ren-shu-qian-andshou-cang">
        </link>
        <updated>2017-08-01T08:26:22.000Z</updated>
        <content type="html"><![CDATA[<h4 id="0-centos7-上安装-redis">0. <a href="http://www.linuxidc.com/Linux/2017-09/147198.htm">CentOS7 上安装 Redis</a></h4>
<h4 id="1-centos7-上部署-rsync-服务">1. <a href="https://www.linuxidc.com/Linux/2017-10/147900.htm">CentOS7 上部署 Rsync 服务</a></h4>
<h4 id="2-linux-目录结构详细介绍">2. <a href="http://yangrong.blog.51cto.com/6945369/1288072">Linux 目录结构详细介绍</a></h4>
<h4 id="3-gitlab-搭建与维护基于-docker">3. <a href="http://www.linuxidc.com/Linux/2016-05/131886.htm">GitLab 搭建与维护(基于 docker)</a></h4>
<h4 id="4-gulp-详细入门教程">4. <a href="http://www.ydcss.com/archives/18/comment-page-5">Gulp 详细入门教程</a></h4>
<h4 id="5-跨域资源共享-cors-详解">5. <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></h4>
<h4 id="6-webpack入门">6. <a href="https://segmentfault.com/a/1190000006178770">Webpack入门</a></h4>
<h4 id="7-react-学习资源汇总">7. <a href="http://www.imooc.com/article/14902">React 学习资源汇总</a></h4>
<h4 id="8-docker-入门">8. <a href="https://segmentfault.com/a/1190000009544565">Docker 入门</a></h4>
<h4 id="9-react-入门">9. <a href="https://segmentfault.com/a/1190000012921279">React 入门</a></h4>
<h4 id="10-30-分钟快速入门-docker-教程">10. <a href="https://mp.weixin.qq.com/s/DY3pLat1ehudP624Io73Hg">30 分钟快速入门 Docker 教程</a></h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 学习笔记]]></title>
        <id>https://slowlog.github.io/post/java-xue-xi-bi-ji</id>
        <link href="https://slowlog.github.io/post/java-xue-xi-bi-ji">
        </link>
        <updated>2017-06-15T08:02:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="java-简述">Java 简述</h3>
<ul>
<li>JRE = JVM + JavaSE标准类库</li>
<li>JDK = JRE + 开发工具集（例如javac编译工具）</li>
<li>Java SE = Java标准版</li>
<li>Java EE = Java企业版</li>
<li>Java ME = 为移动设备提供了基于Java环境的开发与应用平台</li>
<li>Java 执行流程 = 源文件(Program.java)-&gt;编译器-&gt;字节码文件(Program.class)-&gt;解释器-&gt;Program</li>
</ul>
<h3 id="java-数据类型">Java 数据类型</h3>
<pre><code>一、基本数据类型：
byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0

short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0

int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0

long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L

float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0

double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0

char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空

boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false

二、引用数据类型：

类、接口类型、数组类型、枚举类型、注解类型。

区别： 
基本数据类型是值传递，引用数据类型是引用传递

基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。

引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。

例如，有一个类Person,有属性name,age,带有参的构造方法，

Person p = new Person(&quot;zhangsan&quot;,20);

在内存中的具体创建过程是：

1.首先在栈内存中位其p分配一块空间;

2.在堆内存中为Person对象分配一块空间，并为其三个属性设初值&quot;&quot;，0；

3.根据类Person中对属性的定义，为该对象的两个属性进行赋值操作；

4.调用构造方法，为两个属性赋值为&quot;Tom&quot;,20；（注意这个时候p与Person对象之间还没有建立联系）；

5.将Person对象在堆内存中的地址，赋值给栈中的p;通过引用（句柄）p可以找到堆中对象的具体信息。

相关知识：

静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配。

堆区：  一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错

栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限

</code></pre>
<h3 id="java-面向对象">Java 面向对象</h3>
<h3 id="类和对象">类和对象</h3>
<pre><code>1. 类是抽象的概念, 仅仅是模板, 比如说 : &quot;人&quot;
2. 类确定对象将会拥有的特征(属性)和行为(方法)
3. 对象是一个能看得到, 摸得着的具体实物，是类的实例表现
4. 万物皆对象, 客观存在的事物皆为对象
5. 属性是对象具有的各种静态特征
</code></pre>
<h3 id="类的定义-对象实例化的过程">类的定义、对象实例化的过程</h3>
<pre><code>1. 类的重要性 : 所有Java程序都以类class为组织单元
2. 什么是类?
    类是模子, 确定对象将会拥有的特征(属性)和行为(方法)
3. 类的组成 : 属性和方法
4. 定义一个类的步骤 : 
    a. 定义类名
    b. 编写类的属性
    c. 编写类的方法
</code></pre>
<pre><code>对象实例化的过程
1. 声明对象 Person p，在内存的栈区开辟空间
2. 实例对象 new Person()，在内存的堆区开辟空间
3. 赋值 Person p = new Person()，将堆空间的地址赋值给栈空间
</code></pre>
<h3 id="成员变量和局部变量">成员变量和局部变量</h3>
<pre><code>1. 成员变量
      在类中定义, 用来描述对象将要有什么
      成员变量可以被本类的所有方法使用, 也可以被与本类有关系的其他方法使用
2. 局部变量
      在类的方法中定义, 在方法中临时保存数据
      只能在本方法中使用
区别 : 
      1. 作用域不同
        局部变量的作用域仅限于定义它的方法
        成员变量的作用域在整个类的内部都是可见的
      2. 初始值不同
        Java会给成员变量一个初始值
        Java不会给局部变量赋予初始值
      3. 在同一个方法中不允许有同名局部变量
        在不同的方法中, 可以有同名局部变量
      4. 两类变量同名时, 局部变量具有更高的优先级
</code></pre>
<h3 id="构造方法-静态变量与方法">构造方法、静态变量与方法</h3>
<pre><code>构造方法
1. 使用new + 构造方法 创建一个新的对象
2. 构造方法是定义在Java类中的一个用来初始化对象的方法
3. 构造方法名与类同名且没有返回值
4. 无参构造方法：当没有指定构造方法时, 系统会自动添加无参的构造方法
5. 构造方法的重载：方法名相同, 但参数不同的多个方法, 调用时会自动根据不同的参数选择相应的方法
</code></pre>
<pre><code>静态变量与方法

Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。
静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问~~
static 可以修饰变量、方法和代码块
PS : 静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！~~

1.静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。
    如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。
2.在普通成员方法中，则可以直接访问同类的非静态变量和静态变量
3.静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。
</code></pre>
<h3 id="初始化块代码块">初始化块（代码块）</h3>
<pre><code>
代码块：在Java中，使用{}括起来的代码成为代码块
根据其位置和声明的不同，可以分为
	局部代码块：局部位置，用于限定变量的生命周期
	构造代码块：在类中的成员位置，用{}括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。
		作用：可以把多个构造方法的共同代码放在一起。
	静态代码块：在类中的成员位置，用{}括起来的代码，只不过它用static修饰
		作用：一般是对类进行初始化
	面试题？
		静态代码块、构造代码块、构造方法的执行顺序？
		静态-》构造代码块-》构造方法
		静态代码块：只执行一次
		构造方法：每次调用构造方法都执行
 
</code></pre>
<h3 id="封装-继承-多态">封装、继承、多态</h3>
<pre><code>封装
1.概念 : 
  将类的某些信息隐藏在类内部, 不允许外部程序直接访问, 而是通过该类提供的方法来实现对隐藏信息的操作和访问
2.好处 : 
  a.只能通过规定的方法访问数据
  b.隐藏类的实例细节, 方便修改和实现
3.封装的实现步骤 : 
  第一步, 修改属性的可见性---设为private
  第二步, 创建getter/setter方法---用于属性读写
  第三步, 在getter/setter方法中加入属性控制语句---对属性值的合法性进行判断

</code></pre>
<pre><code>继承
1. Java中的继承是单一继承(一个子类只能有一个父类)
2. 继承是类与类的一种关系, 是一种&quot;A is a B&quot;的关系，例如说：学生是人，狗和猫都是动物 
3. 继承的好处：子类拥有父类所有的属性和方法，属性和方法的修饰符不能是&quot;private&quot;，实现代码复用，缩短开发周期
4. 继承的初始化构建顺序：父类静态成员-&gt;子类静态成员-&gt;父类对象构建-&gt;子类对象构建

</code></pre>
<pre><code>多态
1. 对象的多种形态，继承是多态的实现基础
2. 父类的引用可以指向本类或子类的实例(子类的引用不可以指向父类，必须通过强制转换)
3. 创建本类对象时, 调用的方法为本类的方法或为子类重写的方法或者继承的方法
</code></pre>
<h3 id="引用类型转换">引用类型转换</h3>
<pre><code>1. 向上类型转换(隐式/自动类型转换), 是小类型到大类型的转换
2. 向下类型转换(强制类型转换), 是大类型到小类型
   ps : 向上类型转换(无风险), 向下类型转换(有风险)
3. instanceof运算符, 来解决引用对象的类型, 避免类型转换的安全性问题

</code></pre>
<h3 id="java中的包package">Java中的包(package)</h3>
<pre><code>1. 包的作用:
    管理Java文件
    解决同名文件冲突
2. 定义包 : package 包名
    注 : 必须放在Java源程序的第一行
          包名可以用&quot;.&quot;号隔开
3. 系统中的包
    java.(功能).(类)
    java.lang.(类)  包含java语言基础的类
    java.util.(类)  包含java语言中各种工具类
    java.io.(类)  包含输入,输出相关功能
4. 包的使用
    (1),可以通过import关键字, 在某个文件使用其他文件中的类.
    (2),Java中, 包的命名规范全是小写字母拼写
    (3),使用的时候不但可以加载某个包下的所有文件, 也可以加载某个具体子包下的所有文件

</code></pre>
<h3 id="java中的访问修饰符">Java中的访问修饰符</h3>
<pre><code>访问修饰符 --- 可以修饰属性和方法的访问范围
访问修饰符  本类  同包  子类  其他
private     √
默认         √     √
protected   √      √    √
public      √      √    √    √

</code></pre>
<h3 id="java中的-this-super-final-关键字">Java中的 this、super、final 关键字</h3>
<pre><code>ps：在构造方法中，this和super是不能同时出现的

this
1. this关键字代表当前类对象的引用
2. 通过this关键字可以访问当前类的构造方法，成员属性，成员方法，不能在静态方法中使用

   
super
1. super关键字代表父类对象的引用
2. 通过super关键字可以访问父类的构造方法，成员属性，成员方法，不能在静态方法中使用

final
1. final关键字，使用final关键字做标识有&quot;最终的&quot;含义
2. final可以修饰类, 方法, 属性和变量
   final修饰类, 则该类不允许被继承
   final修饰方法, 则该方法不允许被覆盖(重写)
   final修饰属性，则该类的属性不会进行隐式的初始化(类的初始化属性必须有值)，或者在构造方法中赋值(但只能选其一)
   final修饰变量, 则该变量的值只能赋一次值, 即为常量

</code></pre>
<h3 id="方法重写与方法重载">方法重写与方法重载</h3>
<pre><code>重写：
在满足继承关系的子类中，方法名，参数个数，顺序，返回值与父类相同，访问修饰符的限定范围大于等于父类方法

重载：
在同一个类中，方法名相同，参数个数，顺序，类型不同，返回值类型，访问修饰符任意

</code></pre>
<h3 id="object类-抽象类">Object类、抽象类</h3>
<pre><code>Object类是所有类的父类，每个类都可以使用Object类中定义的方法
例如：equals()，toString()

</code></pre>
<pre><code>抽象类
1. 语法定义 : 
   抽象类前使用abstract关键字修饰, 则该类为抽象类
2. 应用场景 : 
   a.在某些情况下, 某个父类只是知道其子类应该包含怎样的方法, 但无法准确知道这些子类如何实现这些方法
     也就是说抽象类是约束子类必须有哪些方法, 而并不关注子类是如何实现的
   b.从多个具有相同特征的类中抽象出一个抽象类, 以这个抽象类作为子类的模板, 从而避免了子类设计的随意性
3. 作用 : 
   限制规定子类必须实现某些方法, 但不关注实现细节
4. 使用规则 : 
   a. abstract定义抽象类
   b. abstract定义抽象方法, 只有声明, 不需要实现
   c. 包含抽象方法的类是抽象类
   d. 抽象类中可以包含普通方法, 也可以没有抽象方法
   e. 抽象类不能直接创建, 可以定义引用变量

</code></pre>
<h3 id="接口">接口</h3>
<pre><code>1. 接口概念 :  (是一种规范, 是用来约束类的)
   接口可以理解为一种特殊的类, 由全局常量和公共的抽象方法所组成
   类是一种具体的实现体, 而接口定义了某一批类所需要遵守的规范, 接口不关心这些类的内部数据, 
   也不关心这些类里方法的实现细节, 它只规定这些类里必须提供某些方法
2. 接口定义 
   和类定义不同, 定义接口不再使用class关键字, 而是使用interface关键字
接口定义的基本语法 : 
   [修饰符] (abstract 此关键字肯定有, 如果没有,系统会默认加上) interface 接口名 [extends 父接口1, 父接口2...]
   {
     零到多个常量定义...
     零到多个抽象方法的定义...  
   }
   接口就是用来被继承, 被实现的, 修饰符一般建议用public
   ps : 不能使用private和protected修饰接口
3. 常量 : 
   接口中的属性是常量, 即使定义时不添加 public static final 修饰符, 系统也会自动加上
4. 方法 : 
   接口中的方法只能是抽象方法, 即使定义时不添加public abstract 修饰符, 系统也会自动加上
5. 使用接口 : 
   一个类可以实现一个或者多个接口, 实现接口可以使用implements关键字. Java中的一个类只能继承一个父类,
   是不够灵活的, 通过实现过个接口可以做补充
   继承父类实现接口的语法为 : 
   [修饰符] class 类名 extends 父类 implements 接口1, 接口2...
   {
      类体部分  // 如果继承了抽象类, 需要实现继承的抽象方法; 要实现接口中的抽象方法
   }
   如果要继承父类, 继承父类必须在实现接口之前
使用接口 : 
   接口在使用过程当中, 还经常与匿名内部类配合使用
   匿名内部类就是没有名字的内部类
   多用于关注实现而不关注实现类的名称

</code></pre>
<h3 id="java中的内部类">Java中的内部类</h3>
<pre><code>1. 概念 : 
   内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类
2. 作用 : 
   1. 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
   2. 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
   3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便
3. 种类 : 
   成员内部类
   静态内部类
   方法内部类
   匿名内部类
PS : 
   1.外部类是不能直接使用内部类的成员和方法的
     可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。
   2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法
     如果要访问外部类的成员变量，可以使用 this 关键字。
Java 中的静态内部类
   静态内部类是 static 修饰的内部类，这种内部类的特点是：
      1.静态内部类不能直接访问外部类的非静态成员，但可以通过new 外部类().成员的方式访问 
      2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；
        如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员
      3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();
Java 中的方法内部类
   方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。
   ps : 由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。

</code></pre>
<h3 id="设计模式的三大分类">设计模式的三大分类</h3>
<p>设计模式是基于场景的解决方案</p>
<pre><code>1. 创建型模式

单例模式：某个类只能有一个实例，提供一个全局的访问点。（恶汉式线程安全，懒汉式存在线程风险）

简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。

工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。

抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。

建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。

原型模式：通过复制现有的实例来创建新的实例。


2. 结构型模式 
适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。

组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。

装饰模式：动态的给对象添加新的功能。

代理模式：为其他对象提供一个代理以便控制这个对象的访问。

亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。

外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。

桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。


3. 行为型模式
模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。

解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。

策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。

状态模式：允许一个对象在其对象内部状态改变时改变它的行为。

观察者模式：对象间的一对多的依赖关系。

备忘录模式：在不破坏封装的前提下，保持对象的内部状态。

中介者模式：用一个中介对象来封装一系列的对象交互。

命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。

访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。

责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。

迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
</code></pre>
<h3 id="相关资源">相关资源</h3>
<ul>
<li><code>http://www.runoob.com/java/java-interfaces.html</code></li>
<li><code>https://www.cnblogs.com/pony1223/p/7608955.html</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《计算机是怎样跑起来的》读书笔记]]></title>
        <id>https://slowlog.github.io/post/lesslessji-suan-ji-shi-zen-yang-pao-qi-lai-de-greatergreater-du-shu-bi-ji</id>
        <link href="https://slowlog.github.io/post/lesslessji-suan-ji-shi-zen-yang-pao-qi-lai-de-greatergreater-du-shu-bi-ji">
        </link>
        <updated>2016-06-05T08:24:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="计算机的输入-运算-输出">计算机的输入、运算、输出</h3>
<p>从硬件上来讲，可以说计算机是执行输入、运算、输出三种操作的机器。计算机的硬件由大量的IC（集成电路）组成，每块IC上都有大量的引脚，这些引脚有些用于输入，有些用于输出。IC会在其内部对外部输入的信息进行运算，并把运算结果输出到外部。运算这个词听起来也许有些难以理解，但实际上就是计算的意思。举例来说，1+2=3，计算机所做的事就是“输入”数据1和2，然后对它们进行加法“运算”，最后“输出”计算结果3。</p>
<p>其实计算机就是一台简单的机器，它也只能做这三件事。输入、运算、输出必须成套出现，缺一不可。为什呢？</p>
<ul>
<li>第一，现在的计算机还没有发展到能通过自发的思考创造出信息的地步，因此不输入信息计算计就不能工作。</li>
<li>第二，计算机不能不执行任何运算，如果只是使输入的信息绕过运算环节直接输出，那么这就是电线而不是计算机了，如果不进行运算，计算机也就没有什么存在的意义了。</li>
<li>第三，如果不输出结果，那么这也不是计算机而只是堆积信息的垃圾箱了，所以输出也必不可少。</li>
</ul>
<h3 id="程序是指令和数据的集合">程序是指令和数据的集合</h3>
<p>什么是程序？所谓程序，其实非常简单，只不过是指令和数据的集合。无论程序多么高深多么复杂，其内容也都是指令和数据。
那什么是指令？所谓指令，就是控制计算进行输入、运算、输出的命令。</p>
<p>程序中的数据分为两类，一类是作为指令执行对象的输入数据， 一类是从指令的执行结果得到的输出数据。一般在编写程序的过程中，都要先编译再执行，所谓编译就是把用编译型语言如C、Java、C#等编写的源文件转换成字节码文件，也可以说是机器语言或原生代码。因为计算机只认识二进制，只认识0和1，由一大堆的二进制代码组成的程序就叫机器码、机器语言。</p>
<pre><code>        1 bit  = 1 二进制数据
        1 byte = 8 bit
        1 字母 = 1 byte = 8 bit
        1 汉字 = 2 byte = 16 bit
</code></pre>
<h3 id="计算机的处理方式">计算机的处理方式</h3>
<p>计算机有计算机的处理方法，这是三大原则中的最后一点。计算机本身只不过是为我们处理特定工作的机器。如果计算机能自己干活的话，那么我们的生活太美好了，我一定买很多台。不过遗憾的是目前还没有这样的计算机，现在的计算机终究是受人支配的工具。</p>
<p>对计算机来说什么都是数字。用数字表示所有信息，这就是一个很具代表性的计算机式的处理方式，这一点正是和人类的思维习惯不一样的地方。例如，人们会用”蓝色“”红色“之类的词语描述有关的颜色信息。可是换做计算机的话，就不得不用数字表示颜色信息。</p>
<p>例如：用”0,0,255“表示蓝色，用”255,0,0“表示红色，用”255,0,255“表示由蓝色和红色混合而成的紫色。不光是颜色，计算机对文字的处理也是如此。计算机内部会先把文字转换成相应的数字再做处理，这样的数字叫做”字符编码“。总之，计算机会什么都用数字来表示。</p>
<h3 id="程序的流程分为三种">程序的流程分为三种</h3>
<p><img src="https://user-images.githubusercontent.com/16852041/38287659-66b0a2f8-37fe-11e8-9f11-28f62e538040.png" alt="default">
<img src="https://user-images.githubusercontent.com/16852041/38287664-6dbb0d54-37fe-11e8-9425-73e2dddc6d04.png" alt="default">
<img src="https://user-images.githubusercontent.com/16852041/38303396-89f2e2f0-3838-11e8-9d7e-012183a6736f.png" alt="wx20180404-184523"></p>
<ul>
<li>顺序执行是按照指令记录在内存中的先后顺序依次执行的一种流程。</li>
<li>而循环则是在程序的特定范围内反复执行若干次的一种流程。</li>
<li>条件分支是根据若干个条件的成立与否，在程序的流程中产生若干个分支的一种流程。</li>
</ul>
<p>无论规模多么大多么复杂的程序，都是通过把以上三种流程组合起来实现的。</p>
<h3 id="面向对象编程抽象">面向对象编程&amp;抽象</h3>
<p>面向对象编程是一种基于以下思路的程序设计方法:将关注点置于对象(Object)本身，对象的构成要素包含对象的行为及操作 B，以此为基础进行编程。这种方法使程序易于复用，软件的生产效率因而得以提升。其中所使用的主要编程技巧有继承、封装、多态三种。</p>
<ul>
<li>观点1：面向对象编程通过把组件拼装到一起构建程序</li>
<li>观点2：面向对象编程能够提升程序的开发效率和可维护性</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16852041/38287879-d102061e-37ff-11e8-8b74-049d11e37756.png" alt="wx20180404-120028"></p>
<ul>
<li>观点3：面向对象编程就是在为现实世界建模</li>
</ul>
<p>程序可以在计算机上实现现实世界中的业务和娱乐活动。计算机 本身并没有特定的用途，而是程序赋予了计算机各种各样的用途。在面向对象编程中，可以通过“这个是由什么样的对象构成的呢?”这样的观点来分析即将转换成程序的现实世界。这种分析过程叫作“建模”。 可以说建模对于开发者而言，反映的是他们的世界观，也就是在他们的眼中现实世界看起来是什么样子的。
<img src="https://user-images.githubusercontent.com/16852041/38287893-e43ebe84-37ff-11e8-9409-5bc5bed1026d.png" alt="wx20180404-114525"></p>
<ul>
<li>观点4：面向对象编程可以借助 UML 设计程序
<img src="https://user-images.githubusercontent.com/16852041/38287897-ea38aca0-37ff-11e8-8ad1-df612f347cce.png" alt="wx20180404-115909"></li>
</ul>
<p>面向对象软件开发的一个基本方法就是抽象，到底什么是抽象呢?
抽象是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征。
例如苹果、香蕉、生梨、葡萄、桃子等，它们共同的特性就是水果。
得出水果概念的过程，就是一个抽象的过程。
要抽象，就必须进行比较，没有比较就无法找到共同的部分。
共同特征是指那些能把一类事物与他类事物区分开来的特征，
这些具有区分作用的特征又称本质特征。</p>
<p>因此抽取事物的共同特征就是抽取事物的本质特征，舍弃不同特征。
所以抽象的过程也是一个裁剪的过程，不同的、非本质性的特征全部裁剪掉了。
所谓的共同特征，是相对的，是指从某一个刻面看是共同的。
比如，对于汽车和大米，从买卖的角度看都是商品，都有价格，
这是他们的共同的特征，而从其他方面来比较是，他们则是不同的。</p>
<p>所以在抽象时，同与不同，决定于从什么角度上来抽象。
抽象的角度取决于分析问题的目的。 在软件开发过程中，
识别稳定的需求、识别核心的需求、识别概念性的需求、
设计系统的架构、定义系统中构件之间的接口关系等等都是抽象的过程，
都是反应系统的本质特征的过程。
抽象的，才是稳定的，才是永恒的。 抽象的反义词是具体。</p>
<p>开发人员往往会说：“你讲的太抽象了，能不能讲的具体一点?”在开发语言中，
有抽象类，有具体类，具体类可以继承自抽象类，可以实例化。
抽象类可以派生出众多的不同的具体类。所谓：“一生二，二生三，三生万物”。
系统的稳定体现在抽象类，系统的变化体现在具体类。抽象类的层次要高于具体类。
系统因抽象而稳定，因抽象而生动。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 常用命令]]></title>
        <id>https://slowlog.github.io/post/linux-chang-yong-ming-ling</id>
        <link href="https://slowlog.github.io/post/linux-chang-yong-ming-ling">
        </link>
        <updated>2016-03-02T08:29:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="文件-目录类">文件、目录类</h3>
<pre><code>cd                     # cd 不加任何参数，返回 home 目录
cd -                   # 返回上一次所在目录,并显示其目录名
cd dir                 # 进入到指定目录
pwd                    # 显示当前目录的绝对路径
ls -l                  # 列出文件的详细信息,可简写为 ll
ls | grep &quot;bin&quot;        # 列出包含 &quot;bin&quot; 关键字的文件
mkdir dir              # 创建一个目录
mkdir -p dir/dir       # 创建一个多级目录
mkdir -m 777 dir       # 创建权限为 777 的目录
touch file             # 创建新的空文件
rmdir dir              # 删除空目录
rmdir -p dir/bin       # 删除子空目录 bin 和其父空目录 dir
rm -rf dir/bin         # 删除一个目录中的一个或多个文件或目录, 谨慎使用
rm -rf *.log           # 删除当前目录下所有 &quot;.log&quot; 的文件
find fileName ‐name  *.txt | xargs rm ‐rf   # 将查找出来的文件全部删除, 谨慎使用
cp file dir/file       # 将文件或目录拷贝到另一文件或目录中 
cp ‐R dir1 dir2 /dir   # 拷贝多个目录 (含子目录) 到指定目录
mv dir1 dir2           # 将文件或目录重新命名,或者将文件从一个目录移到另一个目录中
sz fileName            # 下载指定文件到本地
rz                     # 上传文件到服务器
</code></pre>
<h3 id="文件查看-处理">文件查看、处理</h3>
<pre><code>cat file                 # 显示文件的内容
cat -n file              # 从1开始对文件的行数编号
cat file1 file2 &gt; file3  # 将文件 file1 和 file2 的内容合并之后放入 file3 中    
head file                # 显示文件的头 10 行内容
tail file                # 显示文件的最后 10 行内容 
tail -f file             # 显示文件最新追加的内容,并监视文件的变化,常用来跟踪日志文件
more file                # 基于vi编辑器文本过滤器,它以全屏幕的方式按页显示文本文件的内容 
less file                # 作用与 more 十分类似, pageUp 向上翻页, pageDown 向下翻页, q 退出 
cat file1 &gt; file2        # 覆盖导入
cat file1 &gt;&gt; file        # 追加导入
wc ‐l [‐m][‐c][‐w] file  # 统计行数、字符数、字节数、单词数
</code></pre>
<h3 id="文件查询-搜索">文件查询、搜索</h3>
<pre><code>grep keyWord                             # 常与 cat 搭配使用 cat file | grep keyWord
find dir -name &quot;*.log&quot;                   # 搜索指定目录下的 &quot;.log&quot; 文件
find dir -name &quot;*.log&quot; -o -name &quot;*.pid&quot;  # 搜索指定目录下的 &quot;.log&quot; 文件和 &quot;.pid&quot; 文件
find dir -user user1                     # 搜索指定目录下属于 user1 用户的文件
</code></pre>
<h3 id="文本编辑-vi-底行模式下">文本编辑 vi 底行模式下</h3>
<pre><code>:set nu               # 显示行号
:set nonu             # 不显示行号
:n                    # 跳转到指定第 n 行
:w file               # 另存为
:n1,n2 s/str1/str2/g  # 从 n1 行到 n2 行, 将 str1 替换为 str2
:wq                   # 保存并退出
:q!                   # 强制退出不保存
</code></pre>
<h3 id="文本编辑-vi-命令模式下">文本编辑 vi 命令模式下</h3>
<pre><code>G                # 到末行
gg               # 到首行
dd               # 删除行
u                # 撤销
yy               # 复制一行
nyy              # 复制 n 行
p                # 粘贴
</code></pre>
<h3 id="权限管理">权限管理</h3>
<pre><code>chmod 755 dir/file        # 修改指定文件的权限
chmod ‐R 755 dir          # 递归修改目录及其子文件、目录的权限  
chown user file           # 改变文件的所有者  
chown ‐R user dir         # 改变目录的所有者  
chgrp group1 file         # 改变文件的所有者 
chgrp ‐R group1 dir       # 改变目录的所属组  
chown user1:group1 file   # 同时改变文件的所有者和所属组   
chown ‐R user1:group1 dir # 同时改变目录的所有者和所属组   
whoami                    # 查看当前操作用户  
who                       # 查看当前已登录系统的用户  
id user1                  # 查看用户 user1 的归属 id 信息 
</code></pre>
<h3 id="压缩-解压">压缩、解压</h3>
<pre><code>tar -cvf test.tar test.log      # 仅打包,不压缩
tar -xvf test.tar               # 直接解包
tar -zcvf test.tar.gz test.log  # 打包后,以 gzip 压缩
tar -zcvf test.tar.gz *         # 将当前目录下所有文件压缩
tar -zxvf test.tar.gz           # 直接解压
tar ‐zxvf test.tar.gz ‐C dir    # 解压到新目录,只能是 dir 且已经存在
gzip *                          # 压缩目录下所有文件
gzip -d *                       # 解压缩目录下所有文件
zip test.zip *                  # 将当前目录下所有文件压缩为 zip 包
unzip test.zip                  # 解压缩 zip 包
</code></pre>
<h3 id="用户管理">用户管理</h3>
<pre><code>groupadd group1              # 创建组
groupdel group1              # 删除组
groupmod  ‐n group2 group1   # 将 group1 重命名 group2  
useradd user1                # 创建用户
useradd ‐g group1 user1      # 创建 user1 并将其分配到 group1 组下  
userdel ‐r user1             # 删除 user1, &quot;‐r&quot; 参数表示同时也删除 home 目录下的相关目录  
usermod ‐g group2 user1      # 改变 user1 的组为 group2  
usermod ‐G group2 user1      # 将 user1 的添加到 group2 组中来，同时保留原来的主组  
passwd                       # 修改当前用户密码 
passwd user1                 # 修改 user1 用户的密码，仅限 root 用户执行  
su user1                     # 切换到用户 user1 
groups user1                 # 查看用户 user1 所属的组 
</code></pre>
<h3 id="网络配置管理">网络配置管理</h3>
<pre><code>ifconfig -a                  # 查看 ip 信息
ping 127.0.0.1               # 测试主机之间网络的连通性,执行 ping 命令会使用 ICMP 传输协议
ping 192.168.0.1             # 测试从我们的电脑到路由器之间的是否通畅
ping 192.168.0.1 -t -l 65500 # 丢包检查
service network restart      # 重启网络服务 [start , stop]
hostname                     # 查看主机名
netstat -ntlp                # 查询当前系统监听 tcp 端口的进程
</code></pre>
<h3 id="远程连接">远程连接</h3>
<pre><code>ssh root@112.74.95.60                      # 远程连接 shell  
logout                                     # 退出连接  
scp ‐r root@112.74.95.60:/user/local/logs  # 远程复制目录,复制文件时不用加 &quot;‐r&quot; 
</code></pre>
<h3 id="查看命令帮助">查看命令帮助</h3>
<pre><code>help cd       # 用于内部命令, 如 exit、history、cd、echo 等常驻内存  
ls ‐‐help     # 主要用于外部命令,可通过 &quot;echo $PATH&quot; 命令查看外部命令的存储路径,如 ls,vi 等  
man ls        # 命令手册,可用于所有命令,输入&quot;q&quot;可退出  
type cd       # 查看命令类型,内部 or 外部及命令位置 
</code></pre>
<h3 id="系统相关命令">系统相关命令</h3>
<pre><code>shutdown  ‐h now                    # 立即关机  
shutdown  ‐r now                    # 立即重启  
uname ‐r                            # 查看内核版本   
cal                                 # 日历  
date                                # 时间、日期  
date ‐s &quot;2015‐12‐22 08:00&quot;          # 修改时间  
ntpdate time.nist.gov               # 同步当前时间
history                             # 查看历史命令记录,运行时 &quot;!&quot;+ 命令号,如 !3314 运行 3314 命令  
ps -ef                              # 查看进程  
kill pid                            # 终止进程  
kill ‐9 pid                         # 制终止进程  
top                                 # 查看当前系统资源使用率  
df ‐h                               # 查看磁盘信息  
free ‐m                             # 查看内存信息  
du ‐h file/dir                      # 查看文件/目录大小 ‐h 表示以 K,M,G  
du ‐sh file/dir                     # 查看文件/目录总大小  
mount ‐o loop linux.iso /mnt/dir    # 加载文件系统到指定的加载点
umount /mnt/dir                     # 卸载已经加载的文件系统
rpm ‐ivh xxx.rpm                    # 安装 rpm 包  
rpm ‐e xxx.rpm                      # 卸载 rpm 包 
wget http://url                     # 下载远端 zip 包
echo &gt; fileNme                      # 清空文件内容
</code></pre>
<h3 id="其他">其他</h3>
<pre><code>tree -L 1  #显示一级目录和文件
tree -L 1 -d  #只显示一级目录

# 启用正则（命令行）
shopt -s extglob 
# 单个文件或是文件夹反选
rm -rf !(file1)
# 多个文件或是文件夹反选
rm -rf !(file1|file2)


# 停止firewalld服务
systemctl stop firewalld   
# 禁用firewalld服务
systemctl mask firewalld
 
# 安装iptables
yum install -y iptables
yum update iptables
yum install -y iptables-services
 
# 启用服务
systemctl enable iptables.service
systemctl start iptables.service
 
# 开放80端口
vim /etc/sysconfig/iptables
-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT
  
# 重启服务
systemctl restart iptables.service
  
# 查看已添加规则
iptables -L -n -v

</code></pre>
]]></content>
    </entry>
</feed>